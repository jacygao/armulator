//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace NetworkWatcherController
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface INetworkWatchersController
    {

        /// <remarks>
        /// Creates or updates a network watcher in the specified resource group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters that define the network watcher resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>

        System.Threading.Tasks.Task<NetworkWatcher> CreateOrUpdateAsync(string resourceGroupName, string networkWatcherName, NetworkWatcher parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets the specified network watcher by resource group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a network watcher resource.</returns>

        System.Threading.Tasks.Task<NetworkWatcher> GetAsync(string resourceGroupName, string networkWatcherName, string api_version, string subscriptionId);

        /// <remarks>
        /// Deletes the specified network watcher resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Accepted and the operation will complete asynchronously.</returns>

        System.Threading.Tasks.Task DeleteAsync(string resourceGroupName, string networkWatcherName, string api_version, string subscriptionId);

        /// <remarks>
        /// Updates a network watcher tags.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters supplied to update network watcher tags.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>

        System.Threading.Tasks.Task<NetworkWatcher> UpdateTagsAsync(string resourceGroupName, string networkWatcherName, TagsObject parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets all network watchers by resource group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a list of network watcher resources.</returns>

        System.Threading.Tasks.Task<NetworkWatcherListResult> ListAsync(string resourceGroupName, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets all network watchers by subscription.
        /// </remarks>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a list of network watcher resources.</returns>

        System.Threading.Tasks.Task<NetworkWatcherListResult> ListAllAsync(string api_version, string subscriptionId);

        /// <remarks>
        /// Gets the current network topology by resource group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters that define the representation of topology.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns the topology of resource group.</returns>

        System.Threading.Tasks.Task<Topology> GetTopologyAsync(string resourceGroupName, string networkWatcherName, TopologyParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Verify IP flow from the specified VM to a location given the currently configured NSG rules.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters that define the IP flow to be verified.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns the result of IP flow verification.</returns>

        System.Threading.Tasks.Task<VerificationIPFlowResult> VerifyIPFlowAsync(string resourceGroupName, string networkWatcherName, VerificationIPFlowParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets the next hop from the specified VM.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters that define the source and destination endpoint.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns the next hop from the VM.</returns>

        System.Threading.Tasks.Task<NextHopResult> GetNextHopAsync(string resourceGroupName, string networkWatcherName, NextHopParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets the configured and effective security group rules on the specified VM.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters that define the VM to check security groups for.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns security group rules on the VM.</returns>

        System.Threading.Tasks.Task<SecurityGroupViewResult> GetVMSecurityRulesAsync(string resourceGroupName, string networkWatcherName, SecurityGroupViewParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Initiate troubleshooting on a specified resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that define the resource to troubleshoot.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful troubleshooting request.</returns>

        System.Threading.Tasks.Task<TroubleshootingResult> GetTroubleshootingAsync(string resourceGroupName, string networkWatcherName, TroubleshootingParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Get the last completed troubleshooting result on a specified resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that define the resource to query the troubleshooting result.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful get troubleshooting result request.</returns>

        System.Threading.Tasks.Task<TroubleshootingResult> GetTroubleshootingResultAsync(string resourceGroupName, string networkWatcherName, QueryTroubleshootingParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Configures flow log and traffic analytics (optional) on a specified resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that define the configuration of flow log.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful request for setting flow log and traffic analytics (optional) configuration.</returns>

        System.Threading.Tasks.Task<FlowLogInformation> SetFlowLogConfigurationAsync(string resourceGroupName, string networkWatcherName, FlowLogInformation parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Queries status of flow log and traffic analytics (optional) on a specified resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that define a resource to query flow log and traffic analytics (optional) status.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful request for query flow log and traffic analytics (optional) status.</returns>

        System.Threading.Tasks.Task<FlowLogInformation> GetFlowLogStatusAsync(string resourceGroupName, string networkWatcherName, FlowLogStatusParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given endpoint including another VM or an arbitrary remote server.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that determine how the connectivity check will be performed.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful request for checking connectivity.</returns>

        System.Threading.Tasks.Task<ConnectivityInformation> CheckConnectivityAsync(string resourceGroupName, string networkWatcherName, ConnectivityParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// NOTE: This feature is currently in preview and still being tested for stability. Gets the relative latency score for internet service providers from a specified location to Azure regions.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that determine Azure reachability report configuration.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful request for Azure reachability report.</returns>

        System.Threading.Tasks.Task<AzureReachabilityReport> GetAzureReachabilityReportAsync(string resourceGroupName, string networkWatcherName, AzureReachabilityReportParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// NOTE: This feature is currently in preview and still being tested for stability. Lists all available internet service providers for a specified Azure region.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher resource.</param>

        /// <param name="parameters">Parameters that scope the list of available providers.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful request for list of available providers.</returns>

        System.Threading.Tasks.Task<AvailableProvidersList> ListAvailableProvidersAsync(string resourceGroupName, string networkWatcherName, AvailableProvidersListParameters parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets Network Configuration Diagnostic data to help customers understand and debug network behavior. It provides detailed information on what security rules were applied to a specified traffic flow and the result of evaluating these rules. Customers must provide details of a flow like source, destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules evaluated for the specified flow and the evaluation results.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="parameters">Parameters to get network configuration diagnostic.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns the result of network configuration diagnostic.</returns>

        System.Threading.Tasks.Task<NetworkConfigurationDiagnosticResponse> GetNetworkConfigurationDiagnosticAsync(string resourceGroupName, string networkWatcherName, NetworkConfigurationDiagnosticParameters parameters, string api_version, string subscriptionId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class NetworkWatchersController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private INetworkWatchersController _implementation;

        public NetworkWatchersController(INetworkWatchersController implementation)
        {
            _implementation = implementation;
        }

        /// <remarks>
        /// Creates or updates a network watcher in the specified resource group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters that define the network watcher resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}")]
        public System.Threading.Tasks.Task<NetworkWatcher> CreateOrUpdate(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] NetworkWatcher parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.CreateOrUpdateAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets the specified network watcher by resource group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a network watcher resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}")]
        public System.Threading.Tasks.Task<NetworkWatcher> Get(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetAsync(resourceGroupName, networkWatcherName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Deletes the specified network watcher resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Accepted and the operation will complete asynchronously.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}")]
        public System.Threading.Tasks.Task Delete(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.DeleteAsync(resourceGroupName, networkWatcherName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Updates a network watcher tags.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters supplied to update network watcher tags.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}")]
        public System.Threading.Tasks.Task<NetworkWatcher> UpdateTags(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] TagsObject parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.UpdateTagsAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets all network watchers by resource group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a list of network watcher resources.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers")]
        public System.Threading.Tasks.Task<NetworkWatcherListResult> List(string resourceGroupName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAsync(resourceGroupName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets all network watchers by subscription.
        /// </remarks>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a list of network watcher resources.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/providers/Microsoft.Network/networkWatchers")]
        public System.Threading.Tasks.Task<NetworkWatcherListResult> ListAll([Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAllAsync(api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets the current network topology by resource group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters that define the representation of topology.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns the topology of resource group.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/topology")]
        public System.Threading.Tasks.Task<Topology> GetTopology(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] TopologyParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetTopologyAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Verify IP flow from the specified VM to a location given the currently configured NSG rules.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters that define the IP flow to be verified.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns the result of IP flow verification.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/ipFlowVerify")]
        public System.Threading.Tasks.Task<VerificationIPFlowResult> VerifyIPFlow(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] VerificationIPFlowParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.VerifyIPFlowAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets the next hop from the specified VM.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters that define the source and destination endpoint.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns the next hop from the VM.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/nextHop")]
        public System.Threading.Tasks.Task<NextHopResult> GetNextHop(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] NextHopParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetNextHopAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets the configured and effective security group rules on the specified VM.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters that define the VM to check security groups for.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns security group rules on the VM.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/securityGroupView")]
        public System.Threading.Tasks.Task<SecurityGroupViewResult> GetVMSecurityRules(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] SecurityGroupViewParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetVMSecurityRulesAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Initiate troubleshooting on a specified resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that define the resource to troubleshoot.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful troubleshooting request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/troubleshoot")]
        public System.Threading.Tasks.Task<TroubleshootingResult> GetTroubleshooting(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] TroubleshootingParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetTroubleshootingAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Get the last completed troubleshooting result on a specified resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that define the resource to query the troubleshooting result.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful get troubleshooting result request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryTroubleshootResult")]
        public System.Threading.Tasks.Task<TroubleshootingResult> GetTroubleshootingResult(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] QueryTroubleshootingParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetTroubleshootingResultAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Configures flow log and traffic analytics (optional) on a specified resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that define the configuration of flow log.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful request for setting flow log and traffic analytics (optional) configuration.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/configureFlowLog")]
        public System.Threading.Tasks.Task<FlowLogInformation> SetFlowLogConfiguration(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] FlowLogInformation parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.SetFlowLogConfigurationAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Queries status of flow log and traffic analytics (optional) on a specified resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that define a resource to query flow log and traffic analytics (optional) status.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful request for query flow log and traffic analytics (optional) status.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryFlowLogStatus")]
        public System.Threading.Tasks.Task<FlowLogInformation> GetFlowLogStatus(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] FlowLogStatusParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetFlowLogStatusAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given endpoint including another VM or an arbitrary remote server.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that determine how the connectivity check will be performed.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful request for checking connectivity.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectivityCheck")]
        public System.Threading.Tasks.Task<ConnectivityInformation> CheckConnectivity(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] ConnectivityParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.CheckConnectivityAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// NOTE: This feature is currently in preview and still being tested for stability. Gets the relative latency score for internet service providers from a specified location to Azure regions.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that determine Azure reachability report configuration.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful request for Azure reachability report.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/azureReachabilityReport")]
        public System.Threading.Tasks.Task<AzureReachabilityReport> GetAzureReachabilityReport(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] AzureReachabilityReportParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetAzureReachabilityReportAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// NOTE: This feature is currently in preview and still being tested for stability. Lists all available internet service providers for a specified Azure region.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the network watcher resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher resource.</param>
        /// <param name="parameters">Parameters that scope the list of available providers.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful request for list of available providers.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/availableProvidersList")]
        public System.Threading.Tasks.Task<AvailableProvidersList> ListAvailableProviders(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] AvailableProvidersListParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAvailableProvidersAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets Network Configuration Diagnostic data to help customers understand and debug network behavior. It provides detailed information on what security rules were applied to a specified traffic flow and the result of evaluating these rules. Customers must provide details of a flow like source, destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules evaluated for the specified flow and the evaluation results.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="parameters">Parameters to get network configuration diagnostic.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns the result of network configuration diagnostic.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/networkConfigurationDiagnostic")]
        public System.Threading.Tasks.Task<NetworkConfigurationDiagnosticResponse> GetNetworkConfigurationDiagnostic(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromBody] NetworkConfigurationDiagnosticParameters parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetNetworkConfigurationDiagnosticAsync(resourceGroupName, networkWatcherName, parameters, api_version, subscriptionId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IPacketCapturesController
    {

        /// <remarks>
        /// Create and start a packet capture on the specified VM.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="packetCaptureName">The name of the packet capture session.</param>

        /// <param name="parameters">Parameters that define the create packet capture operation.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns the resulting packet capture session.</returns>

        System.Threading.Tasks.Task<PacketCaptureResult> CreateAsync(string resourceGroupName, string networkWatcherName, string packetCaptureName, PacketCapture parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets a packet capture session by name.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="packetCaptureName">The name of the packet capture session.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a packet capture session.</returns>

        System.Threading.Tasks.Task<PacketCaptureResult> GetAsync(string resourceGroupName, string networkWatcherName, string packetCaptureName, string api_version, string subscriptionId);

        /// <remarks>
        /// Deletes the specified packet capture session.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="packetCaptureName">The name of the packet capture session.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Delete successful.</returns>

        System.Threading.Tasks.Task DeleteAsync(string resourceGroupName, string networkWatcherName, string packetCaptureName, string api_version, string subscriptionId);

        /// <remarks>
        /// Stops a specified packet capture session.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="packetCaptureName">The name of the packet capture session.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation stops the packet capture session.</returns>

        System.Threading.Tasks.Task StopAsync(string resourceGroupName, string networkWatcherName, string packetCaptureName, string api_version, string subscriptionId);

        /// <remarks>
        /// Query the status of a running packet capture session.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="packetCaptureName">The name given to the packet capture session.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful query of packet capture status.</returns>

        System.Threading.Tasks.Task<PacketCaptureQueryStatusResult> GetStatusAsync(string resourceGroupName, string networkWatcherName, string packetCaptureName, string api_version, string subscriptionId);

        /// <remarks>
        /// Lists all packet capture sessions within the specified resource group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful packet capture enumeration request.</returns>

        System.Threading.Tasks.Task<PacketCaptureListResult> ListAsync(string resourceGroupName, string networkWatcherName, string api_version, string subscriptionId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class PacketCapturesController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IPacketCapturesController _implementation;

        public PacketCapturesController(IPacketCapturesController implementation)
        {
            _implementation = implementation;
        }

        /// <remarks>
        /// Create and start a packet capture on the specified VM.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="packetCaptureName">The name of the packet capture session.</param>
        /// <param name="parameters">Parameters that define the create packet capture operation.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns the resulting packet capture session.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}")]
        public System.Threading.Tasks.Task<PacketCaptureResult> Create(string resourceGroupName, string networkWatcherName, string packetCaptureName, [Microsoft.AspNetCore.Mvc.FromBody] PacketCapture parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.CreateAsync(resourceGroupName, networkWatcherName, packetCaptureName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets a packet capture session by name.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="packetCaptureName">The name of the packet capture session.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a packet capture session.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}")]
        public System.Threading.Tasks.Task<PacketCaptureResult> Get(string resourceGroupName, string networkWatcherName, string packetCaptureName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetAsync(resourceGroupName, networkWatcherName, packetCaptureName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Deletes the specified packet capture session.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="packetCaptureName">The name of the packet capture session.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Delete successful.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}")]
        public System.Threading.Tasks.Task Delete(string resourceGroupName, string networkWatcherName, string packetCaptureName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.DeleteAsync(resourceGroupName, networkWatcherName, packetCaptureName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Stops a specified packet capture session.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="packetCaptureName">The name of the packet capture session.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation stops the packet capture session.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/stop")]
        public System.Threading.Tasks.Task Stop(string resourceGroupName, string networkWatcherName, string packetCaptureName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.StopAsync(resourceGroupName, networkWatcherName, packetCaptureName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Query the status of a running packet capture session.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="packetCaptureName">The name given to the packet capture session.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful query of packet capture status.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/queryStatus")]
        public System.Threading.Tasks.Task<PacketCaptureQueryStatusResult> GetStatus(string resourceGroupName, string networkWatcherName, string packetCaptureName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetStatusAsync(resourceGroupName, networkWatcherName, packetCaptureName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Lists all packet capture sessions within the specified resource group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful packet capture enumeration request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures")]
        public System.Threading.Tasks.Task<PacketCaptureListResult> List(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAsync(resourceGroupName, networkWatcherName, api_version, subscriptionId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IConnectionMonitorsController
    {

        /// <remarks>
        /// Create or update a connection monitor.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="parameters">Parameters that define the operation to create a connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <param name="migrate">Value indicating whether connection monitor V1 should be migrated to V2 format.</param>

        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>

        System.Threading.Tasks.Task<ConnectionMonitorResult> CreateOrUpdateAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, ConnectionMonitor parameters, string api_version, string subscriptionId, string migrate);

        /// <remarks>
        /// Gets a connection monitor by name.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a connection monitor.</returns>

        System.Threading.Tasks.Task<ConnectionMonitorResult> GetAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, string api_version, string subscriptionId);

        /// <remarks>
        /// Deletes the specified connection monitor.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Delete successful.</returns>

        System.Threading.Tasks.Task DeleteAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, string api_version, string subscriptionId);

        /// <remarks>
        /// Update tags of the specified connection monitor.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="parameters">Parameters supplied to update connection monitor tags.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns updated connection monitor.</returns>

        System.Threading.Tasks.Task<ConnectionMonitorResult> UpdateTagsAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, TagsObject parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Stops the specified connection monitor.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation stops the connection monitor.</returns>

        System.Threading.Tasks.Task StopAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, string api_version, string subscriptionId);

        /// <remarks>
        /// Starts the specified connection monitor.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name of the connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation starts the connection monitor.</returns>

        System.Threading.Tasks.Task StartAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, string api_version, string subscriptionId);

        /// <remarks>
        /// Query a snapshot of the most recent connection states.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="connectionMonitorName">The name given to the connection monitor.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful query of connection states.</returns>

        System.Threading.Tasks.Task<ConnectionMonitorQueryResult> QueryAsync(string resourceGroupName, string networkWatcherName, string connectionMonitorName, string api_version, string subscriptionId);

        /// <remarks>
        /// Lists all connection monitors for the specified Network Watcher.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful connection monitor enumeration request.</returns>

        System.Threading.Tasks.Task<ConnectionMonitorListResult> ListAsync(string resourceGroupName, string networkWatcherName, string api_version, string subscriptionId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class ConnectionMonitorsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IConnectionMonitorsController _implementation;

        public ConnectionMonitorsController(IConnectionMonitorsController implementation)
        {
            _implementation = implementation;
        }

        /// <remarks>
        /// Create or update a connection monitor.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="parameters">Parameters that define the operation to create a connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <param name="migrate">Value indicating whether connection monitor V1 should be migrated to V2 format.</param>
        /// <returns>Update successful. The operation returns the resulting network watcher resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}")]
        public System.Threading.Tasks.Task<ConnectionMonitorResult> CreateOrUpdate(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromBody] ConnectionMonitor parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId, [Microsoft.AspNetCore.Mvc.FromQuery] string migrate)
        {

            return _implementation.CreateOrUpdateAsync(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, api_version, subscriptionId, migrate);
        }

        /// <remarks>
        /// Gets a connection monitor by name.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a connection monitor.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}")]
        public System.Threading.Tasks.Task<ConnectionMonitorResult> Get(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetAsync(resourceGroupName, networkWatcherName, connectionMonitorName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Deletes the specified connection monitor.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Delete successful.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}")]
        public System.Threading.Tasks.Task Delete(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.DeleteAsync(resourceGroupName, networkWatcherName, connectionMonitorName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Update tags of the specified connection monitor.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="parameters">Parameters supplied to update connection monitor tags.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns updated connection monitor.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}")]
        public System.Threading.Tasks.Task<ConnectionMonitorResult> UpdateTags(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromBody] TagsObject parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.UpdateTagsAsync(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Stops the specified connection monitor.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation stops the connection monitor.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/stop")]
        public System.Threading.Tasks.Task Stop(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.StopAsync(resourceGroupName, networkWatcherName, connectionMonitorName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Starts the specified connection monitor.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name of the connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation starts the connection monitor.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/start")]
        public System.Threading.Tasks.Task Start(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.StartAsync(resourceGroupName, networkWatcherName, connectionMonitorName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Query a snapshot of the most recent connection states.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="connectionMonitorName">The name given to the connection monitor.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful query of connection states.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/query")]
        public System.Threading.Tasks.Task<ConnectionMonitorQueryResult> Query(string resourceGroupName, string networkWatcherName, string connectionMonitorName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.QueryAsync(resourceGroupName, networkWatcherName, connectionMonitorName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Lists all connection monitors for the specified Network Watcher.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful connection monitor enumeration request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors")]
        public System.Threading.Tasks.Task<ConnectionMonitorListResult> List(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAsync(resourceGroupName, networkWatcherName, api_version, subscriptionId);
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IFlowLogsController
    {

        /// <remarks>
        /// Create or update a flow log for the specified network security group.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="flowLogName">The name of the flow log.</param>

        /// <param name="parameters">Parameters that define the create or update flow log resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Update successful. The operation returns the resulting flow log resource.</returns>

        System.Threading.Tasks.Task<FlowLog> CreateOrUpdateAsync(string resourceGroupName, string networkWatcherName, string flowLogName, FlowLog parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Update tags of the specified flow log.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="flowLogName">The name of the flow log.</param>

        /// <param name="parameters">Parameters supplied to update flow log tags.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns updated flow log.</returns>

        System.Threading.Tasks.Task<FlowLog> UpdateTagsAsync(string resourceGroupName, string networkWatcherName, string flowLogName, TagsObject parameters, string api_version, string subscriptionId);

        /// <remarks>
        /// Gets a flow log resource by name.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="flowLogName">The name of the flow log resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Request successful. The operation returns a flow log resource.</returns>

        System.Threading.Tasks.Task<FlowLog> GetAsync(string resourceGroupName, string networkWatcherName, string flowLogName, string api_version, string subscriptionId);

        /// <remarks>
        /// Deletes the specified flow log resource.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group.</param>

        /// <param name="networkWatcherName">The name of the network watcher.</param>

        /// <param name="flowLogName">The name of the flow log resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Delete successful.</returns>

        System.Threading.Tasks.Task DeleteAsync(string resourceGroupName, string networkWatcherName, string flowLogName, string api_version, string subscriptionId);

        /// <remarks>
        /// Lists all flow log resources for the specified Network Watcher.
        /// </remarks>

        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>

        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>

        /// <param name="api_version">Client API version.</param>

        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>

        /// <returns>Successful flow log enumeration request.</returns>

        System.Threading.Tasks.Task<FlowLogListResult> ListAsync(string resourceGroupName, string networkWatcherName, string api_version, string subscriptionId);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]

    public partial class FlowLogsController : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IFlowLogsController _implementation;

        public FlowLogsController(IFlowLogsController implementation)
        {
            _implementation = implementation;
        }

        /// <remarks>
        /// Create or update a flow log for the specified network security group.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="flowLogName">The name of the flow log.</param>
        /// <param name="parameters">Parameters that define the create or update flow log resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Update successful. The operation returns the resulting flow log resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}")]
        public System.Threading.Tasks.Task<FlowLog> CreateOrUpdate(string resourceGroupName, string networkWatcherName, string flowLogName, [Microsoft.AspNetCore.Mvc.FromBody] FlowLog parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.CreateOrUpdateAsync(resourceGroupName, networkWatcherName, flowLogName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Update tags of the specified flow log.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="flowLogName">The name of the flow log.</param>
        /// <param name="parameters">Parameters supplied to update flow log tags.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns updated flow log.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}")]
        public System.Threading.Tasks.Task<FlowLog> UpdateTags(string resourceGroupName, string networkWatcherName, string flowLogName, [Microsoft.AspNetCore.Mvc.FromBody] TagsObject parameters, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.UpdateTagsAsync(resourceGroupName, networkWatcherName, flowLogName, parameters, api_version, subscriptionId);
        }

        /// <remarks>
        /// Gets a flow log resource by name.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="flowLogName">The name of the flow log resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Request successful. The operation returns a flow log resource.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}")]
        public System.Threading.Tasks.Task<FlowLog> Get(string resourceGroupName, string networkWatcherName, string flowLogName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.GetAsync(resourceGroupName, networkWatcherName, flowLogName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Deletes the specified flow log resource.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group.</param>
        /// <param name="networkWatcherName">The name of the network watcher.</param>
        /// <param name="flowLogName">The name of the flow log resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Delete successful.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}")]
        public System.Threading.Tasks.Task Delete(string resourceGroupName, string networkWatcherName, string flowLogName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.DeleteAsync(resourceGroupName, networkWatcherName, flowLogName, api_version, subscriptionId);
        }

        /// <remarks>
        /// Lists all flow log resources for the specified Network Watcher.
        /// </remarks>
        /// <param name="resourceGroupName">The name of the resource group containing Network Watcher.</param>
        /// <param name="networkWatcherName">The name of the Network Watcher resource.</param>
        /// <param name="api_version">Client API version.</param>
        /// <param name="subscriptionId">The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.</param>
        /// <returns>Successful flow log enumeration request.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs")]
        public System.Threading.Tasks.Task<FlowLogListResult> List(string resourceGroupName, string networkWatcherName, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "api-version")] string api_version, string subscriptionId)
        {

            return _implementation.ListAsync(resourceGroupName, networkWatcherName, api_version, subscriptionId);
        }

    }

    /// <summary>
    /// The error object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorResponse
    {
        /// <summary>
        /// The error details object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDetails Error { get; set; }

    }

    /// <summary>
    /// Network watcher in a resource group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkWatcher : Resource
    {
        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Properties of the network watcher.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkWatcherPropertiesFormat Properties { get; set; }

    }

    /// <summary>
    /// The network watcher properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkWatcherPropertiesFormat
    {
        /// <summary>
        /// The provisioning state of the network watcher resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

    }

    /// <summary>
    /// Response for ListNetworkWatchers API service call.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkWatcherListResult
    {
        /// <summary>
        /// List of network watcher resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkWatcher> Value { get; set; }

    }

    /// <summary>
    /// Parameters that define the representation of topology.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TopologyParameters
    {
        /// <summary>
        /// The name of the target resource group to perform topology on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceGroupName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetResourceGroupName { get; set; }

        /// <summary>
        /// The reference to the Virtual Network resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetVirtualNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource TargetVirtualNetwork { get; set; }

        /// <summary>
        /// The reference to the Subnet resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetSubnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource TargetSubnet { get; set; }

    }

    /// <summary>
    /// Topology of the specified resource group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Topology
    {
        /// <summary>
        /// GUID representing the operation id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The datetime when the topology was initially created for the resource group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createdDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedDateTime { get; set; }

        /// <summary>
        /// The datetime when the topology was last modified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastModified", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastModified { get; set; }

        /// <summary>
        /// A list of topology resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TopologyResource> Resources { get; set; }

    }

    /// <summary>
    /// The network resource topology information for the given resource group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TopologyResource
    {
        /// <summary>
        /// Name of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// ID of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Resource location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        /// <summary>
        /// Holds the associations the resource has with other resources in the resource group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("associations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TopologyAssociation> Associations { get; set; }

    }

    /// <summary>
    /// Resources that have an association with the parent resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TopologyAssociation
    {
        /// <summary>
        /// The name of the resource that is associated with the parent resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The ID of the resource that is associated with the parent resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The association type of the child resource to the parent resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("associationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TopologyAssociationAssociationType? AssociationType { get; set; }

    }

    /// <summary>
    /// Parameters that define the IP flow to be verified.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VerificationIPFlowParameters
    {
        /// <summary>
        /// The ID of the target resource to perform next-hop on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// The direction of the packet represented as a 5-tuple.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Direction Direction { get; set; }

        /// <summary>
        /// Protocol to be verified on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public VerificationIPFlowParametersProtocol Protocol { get; set; }

        /// <summary>
        /// The local port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localPort", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LocalPort { get; set; }

        /// <summary>
        /// The remote port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remotePort", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RemotePort { get; set; }

        /// <summary>
        /// The local IP address. Acceptable values are valid IPv4 addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localIPAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LocalIPAddress { get; set; }

        /// <summary>
        /// The remote IP address. Acceptable values are valid IPv4 addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remoteIPAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string RemoteIPAddress { get; set; }

        /// <summary>
        /// The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of them, then this parameter must be specified. Otherwise optional).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetNicResourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetNicResourceId { get; set; }

    }

    /// <summary>
    /// Results of IP flow verification on the target resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VerificationIPFlowResult
    {
        /// <summary>
        /// Indicates whether the traffic is allowed or denied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Access? Access { get; set; }

        /// <summary>
        /// Name of the rule. If input is not matched against any security rule, it is not displayed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ruleName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RuleName { get; set; }

    }

    /// <summary>
    /// Parameters that define the source and destination endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NextHopParameters
    {
        /// <summary>
        /// The resource identifier of the target resource against which the action is to be performed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// The source IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceIPAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SourceIPAddress { get; set; }

        /// <summary>
        /// The destination IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationIPAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationIPAddress { get; set; }

        /// <summary>
        /// The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of the nics, then this parameter must be specified. Otherwise optional).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetNicResourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetNicResourceId { get; set; }

    }

    /// <summary>
    /// The information about next hop from the specified VM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NextHopResult
    {
        /// <summary>
        /// Next hop type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NextHopResultNextHopType? NextHopType { get; set; }

        /// <summary>
        /// Next hop IP Address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopIpAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextHopIpAddress { get; set; }

        /// <summary>
        /// The resource identifier for the route table associated with the route being returned. If the route being returned does not correspond to any user created routes then this field will be the string 'System Route'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routeTableId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RouteTableId { get; set; }

    }

    /// <summary>
    /// Parameters that define the VM to check security groups for.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityGroupViewParameters
    {
        /// <summary>
        /// ID of the target VM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

    }

    /// <summary>
    /// The information about security rules applied to the specified VM.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityGroupViewResult
    {
        /// <summary>
        /// List of network interfaces on the specified VM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityGroupNetworkInterface> NetworkInterfaces { get; set; }

    }

    /// <summary>
    /// Network interface and all its associated security rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityGroupNetworkInterface
    {
        /// <summary>
        /// ID of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// All security rules associated with the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityRuleAssociations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityRuleAssociations SecurityRuleAssociations { get; set; }

    }

    /// <summary>
    /// All security rules associated with the network interface.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityRuleAssociations
    {
        /// <summary>
        /// Network interface and it's custom security rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaceAssociation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkInterfaceAssociation NetworkInterfaceAssociation { get; set; }

        /// <summary>
        /// Subnet and it's custom security rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnetAssociation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubnetAssociation SubnetAssociation { get; set; }

        /// <summary>
        /// Collection of default security rules of the network security group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultSecurityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityRule> DefaultSecurityRules { get; set; }

        /// <summary>
        /// Collection of effective security rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("effectiveSecurityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<EffectiveNetworkSecurityRule> EffectiveSecurityRules { get; set; }

    }

    /// <summary>
    /// Network interface and its custom security rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkInterfaceAssociation
    {
        /// <summary>
        /// Network interface ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Collection of custom security rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityRule> SecurityRules { get; set; }

    }

    /// <summary>
    /// Subnet and it's custom security rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubnetAssociation
    {
        /// <summary>
        /// Subnet ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Collection of custom security rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityRule> SecurityRules { get; set; }

    }

    /// <summary>
    /// Parameters that define the create packet capture operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCapture
    {
        /// <summary>
        /// Properties of the packet capture.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        public PacketCaptureParameters Properties { get; set; }

    }

    /// <summary>
    /// Parameters that define the create packet capture operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureParameters
    {
        /// <summary>
        /// The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Target { get; set; }

        /// <summary>
        /// A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PacketCaptureMachineScope Scope { get; set; }

        /// <summary>
        /// Target type of the resource provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PacketCaptureParametersTargetType? TargetType { get; set; }

        /// <summary>
        /// Number of bytes captured per packet, the remaining bytes are truncated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bytesToCapturePerPacket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? BytesToCapturePerPacket { get; set; } = 0L;

        /// <summary>
        /// Maximum size of the capture output.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalBytesPerSession", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? TotalBytesPerSession { get; set; } = 1073741824L;

        /// <summary>
        /// Maximum duration of the capture session in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeLimitInSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 18000)]
        public int? TimeLimitInSeconds { get; set; } = 18000;

        /// <summary>
        /// The storage location for a packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageLocation", Required = Newtonsoft.Json.Required.Always)]
        public PacketCaptureStorageLocation StorageLocation { get; set; }

        /// <summary>
        /// A list of packet capture filters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PacketCaptureFilter> Filters { get; set; }

        /// <summary>
        /// This continuous capture is a nullable boolean, which can hold 'null', 'true' or 'false' value. If we do not pass this parameter, it would be consider as 'null', default value is 'null'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continuousCapture", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ContinuousCapture { get; set; }

        /// <summary>
        /// The capture setting holds the 'FileCount', 'FileSizeInBytes', 'SessionTimeLimitInSeconds' values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("captureSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PacketCaptureSettings CaptureSettings { get; set; }

    }

    /// <summary>
    /// A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureMachineScope
    {
        /// <summary>
        /// List of AzureVMSS instances to run packet capture on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("include", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Include { get; set; }

        /// <summary>
        /// List of AzureVMSS instances which has to be excluded from the AzureVMSS from running packet capture.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Exclude { get; set; }

    }

    /// <summary>
    /// The storage location for a packet capture session.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureStorageLocation
    {
        /// <summary>
        /// The ID of the storage account to save the packet capture session. Required if no localPath or filePath is provided.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StorageId { get; set; }

        /// <summary>
        /// The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePath { get; set; }

        /// <summary>
        /// This path is invalid if 'Continuous Capture' is provided with 'true' or 'false'. A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilePath { get; set; }

        /// <summary>
        /// This path is valid if 'Continuous Capture' is provided with 'true' or 'false' and required if no storage ID is provided, otherwise optional. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LocalPath { get; set; }

    }

    /// <summary>
    /// The storage location for a packet capture session.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureSettings
    {
        /// <summary>
        /// Number of file count. Default value of count is 10 and maximum number is 10000.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 10000)]
        public int? FileCount { get; set; } = 10;

        /// <summary>
        /// Number of bytes captured per packet. Default value in bytes 104857600 (100MB) and maximum in bytes 4294967295 (4GB).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileSizeInBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? FileSizeInBytes { get; set; } = 104857600L;

        /// <summary>
        /// Maximum duration of the capture session in seconds is 604800s (7 days) for a file. Default value in second 86400s (1 day).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sessionTimeLimitInSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 604800)]
        public int? SessionTimeLimitInSeconds { get; set; } = 86400;

    }

    /// <summary>
    /// Filter that is applied to packet capture request. Multiple filters can be applied.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureFilter
    {
        /// <summary>
        /// Protocol to be filtered on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PacketCaptureFilterProtocol? Protocol { get; set; } = NetworkWatcherController.PacketCaptureFilterProtocol.Any;

        /// <summary>
        /// Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5"? for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LocalIPAddress { get; set; }

        /// <summary>
        /// Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remoteIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoteIPAddress { get; set; }

        /// <summary>
        /// Local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LocalPort { get; set; }

        /// <summary>
        /// Remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remotePort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemotePort { get; set; }

    }

    /// <summary>
    /// List of packet capture sessions.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureListResult
    {
        /// <summary>
        /// Information about packet capture sessions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PacketCaptureResult> Value { get; set; }

    }

    /// <summary>
    /// Information about packet capture session.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureResult
    {
        /// <summary>
        /// Name of the packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// ID of the packet capture operation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Properties of the packet capture result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PacketCaptureResultProperties Properties { get; set; }

    }

    /// <summary>
    /// The properties of a packet capture session.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureResultProperties : PacketCaptureParameters
    {
        /// <summary>
        /// The provisioning state of the packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

    }

    /// <summary>
    /// Status of packet capture session.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PacketCaptureQueryStatusResult
    {
        /// <summary>
        /// The name of the packet capture resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The ID of the packet capture resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The start time of the packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("captureStartTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CaptureStartTime { get; set; }

        /// <summary>
        /// The status of the packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packetCaptureStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PacketCaptureQueryStatusResultPacketCaptureStatus? PacketCaptureStatus { get; set; }

        /// <summary>
        /// The reason the current packet capture session was stopped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stopReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StopReason { get; set; }

        /// <summary>
        /// List of errors of packet capture session.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("packetCaptureError", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.List<PacketCaptureError> PacketCaptureError { get; set; }

    }

    /// <summary>
    /// Parameters that define the resource to troubleshoot.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TroubleshootingParameters
    {
        /// <summary>
        /// The target resource to troubleshoot.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// Properties of the troubleshooting resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        public TroubleshootingProperties Properties { get; set; }

    }

    /// <summary>
    /// Parameters that define the resource to query the troubleshooting result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryTroubleshootingParameters
    {
        /// <summary>
        /// The target resource ID to query the troubleshooting result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

    }

    /// <summary>
    /// Storage location provided for troubleshoot.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TroubleshootingProperties
    {
        /// <summary>
        /// The ID for the storage account to save the troubleshoot result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StorageId { get; set; }

        /// <summary>
        /// The path to the blob to save the troubleshoot result in.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storagePath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StoragePath { get; set; }

    }

    /// <summary>
    /// Troubleshooting information gained from specified resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TroubleshootingResult
    {
        /// <summary>
        /// The start time of the troubleshooting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// The end time of the troubleshooting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndTime { get; set; }

        /// <summary>
        /// The result code of the troubleshooting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }

        /// <summary>
        /// Information from troubleshooting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TroubleshootingDetails> Results { get; set; }

    }

    /// <summary>
    /// Information gained from troubleshooting of specified resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TroubleshootingDetails
    {
        /// <summary>
        /// The id of the get troubleshoot operation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Reason type of failure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reasonType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReasonType { get; set; }

        /// <summary>
        /// A summary of troubleshooting.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("summary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Summary { get; set; }

        /// <summary>
        /// Details on troubleshooting results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Detail { get; set; }

        /// <summary>
        /// List of recommended actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recommendedActions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TroubleshootingRecommendedActions> RecommendedActions { get; set; }

    }

    /// <summary>
    /// Recommended actions based on discovered issues.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TroubleshootingRecommendedActions
    {
        /// <summary>
        /// ID of the recommended action.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionId { get; set; }

        /// <summary>
        /// Description of recommended actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionText { get; set; }

        /// <summary>
        /// The uri linking to a documentation for the recommended troubleshooting actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionUri", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionUri { get; set; }

        /// <summary>
        /// The information from the URI for the recommended troubleshooting actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionUriText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionUriText { get; set; }

    }

    /// <summary>
    /// List of flow logs.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogListResult
    {
        /// <summary>
        /// Information about flow log resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FlowLog> Value { get; set; }

        /// <summary>
        /// The URL to get the next set of results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextLink { get; set; }

    }

    /// <summary>
    /// A flow log resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLog : Resource
    {
        /// <summary>
        /// Properties of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlowLogPropertiesFormat Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// FlowLog resource Managed Identity
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManagedServiceIdentity Identity { get; set; }

    }

    /// <summary>
    /// Parameters that define the configuration of flow log.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogPropertiesFormat
    {
        /// <summary>
        /// ID of network security group to which flow log will be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// Guid of network security group to which flow log will be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetResourceGuid { get; set; }

        /// <summary>
        /// ID of the storage account which is used to store the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StorageId { get; set; }

        /// <summary>
        /// Optional field to filter network traffic logs based on SrcIP, SrcPort, DstIP, DstPort, Protocol, Encryption, Direction and Action. If not specified, all network traffic will be logged.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabledFilteringCriteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EnabledFilteringCriteria { get; set; }

        /// <summary>
        /// Flag to enable/disable flow logging.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// Parameters that define the retention policy for flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retentionPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetentionPolicyParameters RetentionPolicy { get; set; }

        /// <summary>
        /// Parameters that define the flow log format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlowLogFormatParameters Format { get; set; }

        /// <summary>
        /// Parameters that define the configuration of traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flowAnalyticsConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TrafficAnalyticsProperties FlowAnalyticsConfiguration { get; set; }

        /// <summary>
        /// The provisioning state of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

    }

    /// <summary>
    /// Parameters that define the configuration of flow log.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogProperties
    {
        /// <summary>
        /// ID of the storage account which is used to store the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StorageId { get; set; }

        /// <summary>
        /// Optional field to filter network traffic logs based on SrcIP, SrcPort, DstIP, DstPort, Protocol, Encryption, Direction and Action. If not specified, all network traffic will be logged.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabledFilteringCriteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EnabledFilteringCriteria { get; set; }

        /// <summary>
        /// Flag to enable/disable flow logging.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Parameters that define the retention policy for flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retentionPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetentionPolicyParameters RetentionPolicy { get; set; }

        /// <summary>
        /// Parameters that define the flow log format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlowLogFormatParameters Format { get; set; }

    }

    /// <summary>
    /// Parameters that define a resource to query flow log and traffic analytics (optional) status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogStatusParameters
    {
        /// <summary>
        /// The target resource where getting the flow log and traffic analytics (optional) status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

    }

    /// <summary>
    /// Parameters that define the retention policy for flow log.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetentionPolicyParameters
    {
        /// <summary>
        /// Number of days to retain flow log records.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("days", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Days { get; set; } = 0;

        /// <summary>
        /// Flag to enable/disable retention.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;

    }

    /// <summary>
    /// Parameters that define the flow log format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogFormatParameters
    {
        /// <summary>
        /// The file type of flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FlowLogFormatParametersType? Type { get; set; }

        /// <summary>
        /// The version (revision) of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; } = 0;

    }

    /// <summary>
    /// Information on the configuration of flow log and traffic analytics (optional) .
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLogInformation
    {
        /// <summary>
        /// The ID of the resource to configure for flow log and traffic analytics (optional) .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// Properties of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        public FlowLogProperties Properties { get; set; }

        /// <summary>
        /// Parameters that define the configuration of traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flowAnalyticsConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TrafficAnalyticsProperties FlowAnalyticsConfiguration { get; set; }

        /// <summary>
        /// FlowLog resource Managed Identity
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManagedServiceIdentity Identity { get; set; }

    }

    /// <summary>
    /// Parameters that define the configuration of traffic analytics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficAnalyticsProperties
    {
        /// <summary>
        /// Parameters that define the configuration of traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkWatcherFlowAnalyticsConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TrafficAnalyticsConfigurationProperties NetworkWatcherFlowAnalyticsConfiguration { get; set; }

    }

    /// <summary>
    /// Parameters that define the configuration of traffic analytics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrafficAnalyticsConfigurationProperties
    {
        /// <summary>
        /// Flag to enable/disable traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// The resource guid of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceId { get; set; }

        /// <summary>
        /// The location of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceRegion { get; set; }

        /// <summary>
        /// Resource Id of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceResourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceResourceId { get; set; }

        /// <summary>
        /// The interval in minutes which would decide how frequently TA service should do flow analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trafficAnalyticsInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TrafficAnalyticsInterval { get; set; }

    }

    /// <summary>
    /// Parameters that determine how the connectivity check will be performed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityParameters
    {
        /// <summary>
        /// The source of the connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        public ConnectivitySource Source { get; set; }

        /// <summary>
        /// The destination of connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination", Required = Newtonsoft.Json.Required.Always)]
        public ConnectivityDestination Destination { get; set; }

        /// <summary>
        /// Network protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityParametersProtocol? Protocol { get; set; }

        /// <summary>
        /// Configuration of the protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocolConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProtocolConfiguration ProtocolConfiguration { get; set; }

        /// <summary>
        /// Preferred IP version of the connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferredIPVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPVersion? PreferredIPVersion { get; set; }

    }

    /// <summary>
    /// Parameters that define the source of the connection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivitySource
    {
        /// <summary>
        /// The ID of the resource from which a connectivity check will be initiated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The source port from which a connectivity check will be performed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

    }

    /// <summary>
    /// Parameters that define destination of connection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityDestination
    {
        /// <summary>
        /// The ID of the resource to which a connection attempt will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The IP address or URI the resource to which a connection attempt will be made.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>
        /// Port on which check connectivity will be performed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

    }

    /// <summary>
    /// Information on the connectivity status.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityInformation
    {
        /// <summary>
        /// List of hops between the source and the destination.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectivityHop> Hops { get; set; }

        /// <summary>
        /// The connection status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityInformationConnectionStatus? ConnectionStatus { get; set; }

        /// <summary>
        /// Average latency in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avgLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AvgLatencyInMs { get; set; }

        /// <summary>
        /// Minimum latency in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinLatencyInMs { get; set; }

        /// <summary>
        /// Maximum latency in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxLatencyInMs { get; set; }

        /// <summary>
        /// Total number of probes sent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probesSent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProbesSent { get; set; }

        /// <summary>
        /// Number of failed probes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probesFailed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProbesFailed { get; set; }

    }

    /// <summary>
    /// Information about a hop between the source and the destination.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityHop
    {
        /// <summary>
        /// The type of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// The ID of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The IP address of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>
        /// The ID of the resource corresponding to this hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// List of next hop identifiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> NextHopIds { get; set; }

        /// <summary>
        /// List of previous hop identifiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousHopIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> PreviousHopIds { get; set; }

        /// <summary>
        /// List of hop links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<HopLink> Links { get; set; }

        /// <summary>
        /// List of previous hop links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousLinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<HopLink> PreviousLinks { get; set; }

        /// <summary>
        /// List of issues.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectivityIssue> Issues { get; set; }

    }

    /// <summary>
    /// Hop link.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HopLink
    {
        /// <summary>
        /// The ID of the next hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextHopId { get; set; }

        /// <summary>
        /// Link type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkType { get; set; }

        /// <summary>
        /// Hop link properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HopLinkProperties Properties { get; set; }

        /// <summary>
        /// List of issues.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectivityIssue> Issues { get; set; }

        /// <summary>
        /// Provides additional context on links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Context { get; set; }

        /// <summary>
        /// Resource ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

    }

    /// <summary>
    /// Hop link properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HopLinkProperties
    {
        /// <summary>
        /// Minimum roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeMin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeMin { get; set; }

        /// <summary>
        /// Average roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeAvg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeAvg { get; set; }

        /// <summary>
        /// Maximum roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeMax { get; set; }

    }

    /// <summary>
    /// Information about an issue encountered in the process of checking for connectivity.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityIssue
    {
        /// <summary>
        /// The origin of the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityIssueOrigin? Origin { get; set; }

        /// <summary>
        /// The severity of the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityIssueSeverity? Severity { get; set; }

        /// <summary>
        /// The type of issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectivityIssueType? Type { get; set; }

        /// <summary>
        /// Provides additional context on the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IssueContext> Context { get; set; }

    }

    /// <summary>
    /// A key-value pair that provides additional context on the issue.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IssueContext : System.Collections.Generic.Dictionary<string, string>
    {

    }

    /// <summary>
    /// Configuration of the protocol.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProtocolConfiguration
    {
        /// <summary>
        /// HTTP configuration of the connectivity check.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("HTTPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPConfiguration HTTPConfiguration { get; set; }

    }

    /// <summary>
    /// HTTP configuration of the connectivity check.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPConfiguration
    {
        /// <summary>
        /// HTTP method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HTTPConfigurationMethod? Method { get; set; }

        /// <summary>
        /// List of HTTP headers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<HTTPHeader> Headers { get; set; }

        /// <summary>
        /// Valid status codes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validStatusCodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<int> ValidStatusCodes { get; set; }

    }

    /// <summary>
    /// The HTTP header.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeader
    {
        /// <summary>
        /// The name in HTTP header.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The value in HTTP header.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Geographic and time constraints for Azure reachability report.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureReachabilityReportParameters
    {
        /// <summary>
        /// Parameters that define a geographic location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providerLocation", Required = Newtonsoft.Json.Required.Always)]
        public AzureReachabilityReportLocation ProviderLocation { get; set; }

        /// <summary>
        /// List of Internet service providers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Providers { get; set; }

        /// <summary>
        /// Optional Azure regions to scope the query to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azureLocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> AzureLocations { get; set; }

        /// <summary>
        /// The start time for the Azure reachability report.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartTime { get; set; }

        /// <summary>
        /// The end time for the Azure reachability report.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset EndTime { get; set; }

    }

    /// <summary>
    /// Parameters that define a geographic location.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureReachabilityReportLocation
    {
        /// <summary>
        /// The name of the country.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Country { get; set; }

        /// <summary>
        /// The name of the state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string State { get; set; }

        /// <summary>
        /// The name of the city or town.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string City { get; set; }

    }

    /// <summary>
    /// Azure reachability report details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureReachabilityReport
    {
        /// <summary>
        /// The aggregation level of Azure reachability report. Can be Country, State or City.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggregationLevel", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AggregationLevel { get; set; }

        /// <summary>
        /// Parameters that define a geographic location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providerLocation", Required = Newtonsoft.Json.Required.Always)]
        public AzureReachabilityReportLocation ProviderLocation { get; set; }

        /// <summary>
        /// List of Azure reachability report items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reachabilityReport", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<AzureReachabilityReportItem> ReachabilityReport { get; set; } = new System.Collections.Generic.List<AzureReachabilityReportItem>();

    }

    /// <summary>
    /// Azure reachability report details for a given provider location.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureReachabilityReportItem
    {
        /// <summary>
        /// The Internet service provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Provider { get; set; }

        /// <summary>
        /// The Azure region.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azureLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AzureLocation { get; set; }

        /// <summary>
        /// List of latency details for each of the time series.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("latencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<AzureReachabilityReportLatencyInfo> Latencies { get; set; }

    }

    /// <summary>
    /// Details on latency for a time series.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureReachabilityReportLatencyInfo
    {
        /// <summary>
        /// The time stamp.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeStamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TimeStamp { get; set; }

        /// <summary>
        /// The relative latency score between 1 and 100, higher values indicating a faster connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, 100)]
        public int? Score { get; set; }

    }

    /// <summary>
    /// Constraints that determine the list of available Internet service providers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AvailableProvidersListParameters
    {
        /// <summary>
        /// A list of Azure regions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azureLocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> AzureLocations { get; set; }

        /// <summary>
        /// The country for available providers list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Country { get; set; }

        /// <summary>
        /// The state for available providers list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string State { get; set; }

        /// <summary>
        /// The city or town for available providers list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("city", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string City { get; set; }

    }

    /// <summary>
    /// List of available countries with details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AvailableProvidersList
    {
        /// <summary>
        /// List of available countries.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("countries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<AvailableProvidersListCountry> Countries { get; set; } = new System.Collections.Generic.List<AvailableProvidersListCountry>();

    }

    /// <summary>
    /// Country details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AvailableProvidersListCountry
    {
        /// <summary>
        /// The country name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("countryName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CountryName { get; set; }

        /// <summary>
        /// A list of Internet service providers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Providers { get; set; }

        /// <summary>
        /// List of available states in the country.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<AvailableProvidersListState> States { get; set; }

    }

    /// <summary>
    /// State details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AvailableProvidersListState
    {
        /// <summary>
        /// The state name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StateName { get; set; }

        /// <summary>
        /// A list of Internet service providers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Providers { get; set; }

        /// <summary>
        /// List of available cities or towns in the state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<AvailableProvidersListCity> Cities { get; set; }

    }

    /// <summary>
    /// City or town details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AvailableProvidersListCity
    {
        /// <summary>
        /// The city or town name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cityName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CityName { get; set; }

        /// <summary>
        /// A list of Internet service providers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("providers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Providers { get; set; }

    }

    /// <summary>
    /// Parameters to get network configuration diagnostic.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkConfigurationDiagnosticParameters
    {
        /// <summary>
        /// The ID of the target resource to perform network configuration diagnostic. Valid options are VM, NetworkInterface, VMSS/NetworkInterface and Application Gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// Verbosity level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verbosityLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NetworkConfigurationDiagnosticParametersVerbosityLevel? VerbosityLevel { get; set; }

        /// <summary>
        /// List of network configuration diagnostic profiles.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profiles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<NetworkConfigurationDiagnosticProfile> Profiles { get; set; } = new System.Collections.Generic.List<NetworkConfigurationDiagnosticProfile>();

    }

    /// <summary>
    /// Parameters to compare with network configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkConfigurationDiagnosticProfile
    {
        /// <summary>
        /// The direction of the traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Direction Direction { get; set; }

        /// <summary>
        /// Protocol to be verified on. Accepted values are '*', TCP, UDP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Protocol { get; set; }

        /// <summary>
        /// Traffic source. Accepted values are '*', IP Address/CIDR, Service Tag.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Source { get; set; }

        /// <summary>
        /// Traffic destination. Accepted values are: '*', IP Address/CIDR, Service Tag.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Destination { get; set; }

        /// <summary>
        /// Traffic destination port. Accepted values are '*' and a single port in the range (0 - 65535).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPort", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DestinationPort { get; set; }

    }

    /// <summary>
    /// Results of network configuration diagnostic on the target resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkConfigurationDiagnosticResponse
    {
        /// <summary>
        /// List of network configuration diagnostic results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("results", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkConfigurationDiagnosticResult> Results { get; set; }

    }

    /// <summary>
    /// Network configuration diagnostic result corresponded to provided traffic query.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkConfigurationDiagnosticResult
    {
        /// <summary>
        /// Network configuration diagnostic profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("profile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkConfigurationDiagnosticProfile Profile { get; set; }

        /// <summary>
        /// Network security group result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkSecurityGroupResult", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkSecurityGroupResult NetworkSecurityGroupResult { get; set; }

    }

    /// <summary>
    /// Network configuration diagnostic result corresponded provided traffic query.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkSecurityGroupResult
    {
        /// <summary>
        /// The network traffic is allowed or denied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityRuleAccessResult", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityRuleAccess? SecurityRuleAccessResult { get; set; }

        /// <summary>
        /// List of results network security groups diagnostic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluatedNetworkSecurityGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<EvaluatedNetworkSecurityGroup> EvaluatedNetworkSecurityGroups { get; set; }

    }

    /// <summary>
    /// Results of network security group evaluation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EvaluatedNetworkSecurityGroup
    {
        /// <summary>
        /// Network security group ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkSecurityGroupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NetworkSecurityGroupId { get; set; }

        /// <summary>
        /// Resource ID of nic or subnet to which network security group is applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appliedTo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppliedTo { get; set; }

        /// <summary>
        /// Matched network security rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchedRule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MatchedRule MatchedRule { get; set; }

        /// <summary>
        /// List of network security rules evaluation results.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rulesEvaluationResult", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkSecurityRulesEvaluationResult> RulesEvaluationResult { get; set; }

    }

    /// <summary>
    /// Matched rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MatchedRule
    {
        /// <summary>
        /// Name of the matched network security rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ruleName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RuleName { get; set; }

        /// <summary>
        /// The network traffic is allowed or denied. Possible values are 'Allow' and 'Deny'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

    }

    /// <summary>
    /// Network security rules evaluation result.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkSecurityRulesEvaluationResult
    {
        /// <summary>
        /// Name of the network security rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Value indicating whether protocol is matched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocolMatched", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProtocolMatched { get; set; }

        /// <summary>
        /// Value indicating whether source is matched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceMatched", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SourceMatched { get; set; }

        /// <summary>
        /// Value indicating whether source port is matched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourcePortMatched", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SourcePortMatched { get; set; }

        /// <summary>
        /// Value indicating whether destination is matched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationMatched", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DestinationMatched { get; set; }

        /// <summary>
        /// Value indicating whether destination port is matched.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortMatched", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DestinationPortMatched { get; set; }

    }

    /// <summary>
    /// The direction of the traffic.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Direction
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Inbound")]
        Inbound = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Outbound")]
        Outbound = 1,

    }

    /// <summary>
    /// Parameters that define the operation to create a connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitor
    {
        /// <summary>
        /// Connection monitor location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        /// <summary>
        /// Connection monitor tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// Properties of the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        public ConnectionMonitorParameters Properties { get; set; }

    }

    /// <summary>
    /// Parameters that define the operation to create a connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorParameters
    {
        /// <summary>
        /// Describes the source of connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorSource Source { get; set; }

        /// <summary>
        /// Describes the destination of connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorDestination Destination { get; set; }

        /// <summary>
        /// Determines if the connection monitor will start automatically once created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoStart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutoStart { get; set; } = true;

        /// <summary>
        /// Monitoring interval in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitoringIntervalInSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(30, 1800)]
        public int? MonitoringIntervalInSeconds { get; set; } = 60;

        /// <summary>
        /// List of connection monitor endpoints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorEndpoint> Endpoints { get; set; }

        /// <summary>
        /// List of connection monitor test configurations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("testConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorTestConfiguration> TestConfigurations { get; set; }

        /// <summary>
        /// List of connection monitor test groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("testGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorTestGroup> TestGroups { get; set; }

        /// <summary>
        /// List of connection monitor outputs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorOutput> Outputs { get; set; }

        /// <summary>
        /// Optional notes to be associated with the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Notes { get; set; }

    }

    /// <summary>
    /// Describes the source of connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorSource
    {
        /// <summary>
        /// The ID of the resource used as the source by connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ResourceId { get; set; }

        /// <summary>
        /// The source port used by connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

    }

    /// <summary>
    /// Describes the destination of connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorDestination
    {
        /// <summary>
        /// The ID of the resource used as the destination by connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// Address of the connection monitor destination (IP or domain name).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>
        /// The destination port used by connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpoint
    {
        /// <summary>
        /// The name of the connection monitor endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The endpoint type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorEndpointType? Type { get; set; }

        /// <summary>
        /// Resource ID of the connection monitor endpoint are supported for AzureVM, AzureVMSS, AzureVNet, AzureSubnet, MMAWorkspaceMachine, MMAWorkspaceNetwork, AzureArcVM endpoint type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// Address of the connection monitor endpoint. Supported for AzureVM, ExternalAddress, ArcMachine, MMAWorkspaceMachine endpoint type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>
        /// Filter field is getting deprecated and should not be used. Instead use Include/Exclude scope fields for it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorEndpointFilter Filter { get; set; }

        /// <summary>
        /// Endpoint scope defines which target resource to monitor in case of compound resource endpoints like VMSS, AzureSubnet, AzureVNet, MMAWorkspaceNetwork, AzureArcNetwork.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorEndpointScope Scope { get; set; }

        /// <summary>
        /// Test coverage for the endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("coverageLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorEndpointCoverageLevel? CoverageLevel { get; set; }

        /// <summary>
        /// Location details is optional and only being used for 'AzureArcNetwork' type endpoints, which contains region details.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locationDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorEndpointLocationDetails LocationDetails { get; set; }

        /// <summary>
        /// Subscription ID for connection monitor endpoint. It's an optional parameter which is being used for 'AzureArcNetwork' type endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subscriptionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubscriptionId { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor endpoint scope.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpointScope
    {
        /// <summary>
        /// List of items which needs to be included to the endpoint scope.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("include", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorEndpointScopeItem> Include { get; set; }

        /// <summary>
        /// List of items which needs to be excluded from the endpoint scope.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclude", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorEndpointScopeItem> Exclude { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor endpoint scope item.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpointScopeItem
    {
        /// <summary>
        /// The address of the endpoint item. Supported types are IPv4/IPv6 subnet mask or IPv4/IPv6 IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor endpoint filter.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpointFilter
    {
        /// <summary>
        /// The behavior of the endpoint filter. Currently only 'Include' is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorEndpointFilterType? Type { get; set; }

        /// <summary>
        /// List of items in the filter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorEndpointFilterItem> Items { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor endpoint filter item.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpointFilterItem
    {
        /// <summary>
        /// The type of item included in the filter. Currently only 'AgentAddress' is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorEndpointFilterItemType? Type { get; set; }

        /// <summary>
        /// The address of the filter item.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

    }

    /// <summary>
    /// Describes the connection monitor test group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorTestGroup
    {
        /// <summary>
        /// The name of the connection monitor test group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Value indicating whether test group is disabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disable { get; set; }

        /// <summary>
        /// List of test configuration names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("testConfigurations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> TestConfigurations { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// List of source endpoint names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Sources { get; set; } = new System.Collections.Generic.List<string>();

        /// <summary>
        /// List of destination endpoint names.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<string> Destinations { get; set; } = new System.Collections.Generic.List<string>();

    }

    /// <summary>
    /// Describes a connection monitor test configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorTestConfiguration
    {
        /// <summary>
        /// The name of the connection monitor test configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The frequency of test evaluation, in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("testFrequencySec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TestFrequencySec { get; set; }

        /// <summary>
        /// The protocol to use in test evaluation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorTestConfigurationProtocol Protocol { get; set; }

        /// <summary>
        /// The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferredIPVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorTestConfigurationPreferredIPVersion? PreferredIPVersion { get; set; }

        /// <summary>
        /// The parameters used to perform test evaluation over HTTP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("httpConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorHttpConfiguration HttpConfiguration { get; set; }

        /// <summary>
        /// The parameters used to perform test evaluation over TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcpConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorTcpConfiguration TcpConfiguration { get; set; }

        /// <summary>
        /// The parameters used to perform test evaluation over ICMP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icmpConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorIcmpConfiguration IcmpConfiguration { get; set; }

        /// <summary>
        /// The threshold for declaring a test successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorSuccessThreshold SuccessThreshold { get; set; }

    }

    /// <summary>
    /// Describes the HTTP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorHttpConfiguration
    {
        /// <summary>
        /// The port to connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

        /// <summary>
        /// The HTTP method to use.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorHttpConfigurationMethod? Method { get; set; }

        /// <summary>
        /// The path component of the URI. For instance, "/dir1/dir2".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// The HTTP headers to transmit with the request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestHeaders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<HTTPHeader> RequestHeaders { get; set; }

        /// <summary>
        /// HTTP status codes to consider successful. For instance, "2xx,301-304,418".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validStatusCodeRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> ValidStatusCodeRanges { get; set; }

        /// <summary>
        /// Value indicating whether HTTPS is preferred over HTTP in cases where the choice is not explicit.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferHTTPS", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PreferHTTPS { get; set; }

    }

    /// <summary>
    /// Describes the TCP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorTcpConfiguration
    {
        /// <summary>
        /// The port to connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 65535)]
        public int? Port { get; set; }

        /// <summary>
        /// Value indicating whether path evaluation with trace route should be disabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableTraceRoute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableTraceRoute { get; set; }

        /// <summary>
        /// Destination port behavior.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortBehavior", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorTcpConfigurationDestinationPortBehavior? DestinationPortBehavior { get; set; }

    }

    /// <summary>
    /// Describes the ICMP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorIcmpConfiguration
    {
        /// <summary>
        /// Value indicating whether path evaluation with trace route should be disabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableTraceRoute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableTraceRoute { get; set; }

    }

    /// <summary>
    /// Describes the threshold for declaring a test successful.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorSuccessThreshold
    {
        /// <summary>
        /// The maximum percentage of failed checks permitted for a test to evaluate as successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("checksFailedPercent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ChecksFailedPercent { get; set; }

        /// <summary>
        /// The maximum round-trip time in milliseconds permitted for a test to evaluate as successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? RoundTripTimeMs { get; set; }

    }

    /// <summary>
    /// Describes a connection monitor output destination.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorOutput
    {
        /// <summary>
        /// Connection monitor output destination type. Currently, only "Workspace" is supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorOutputType? Type { get; set; }

        /// <summary>
        /// Describes the settings for producing output into a log analytics workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorWorkspaceSettings WorkspaceSettings { get; set; }

    }

    /// <summary>
    /// Describes the settings for producing output into a log analytics workspace.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorWorkspaceSettings
    {
        /// <summary>
        /// Log analytics workspace resource ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceResourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceResourceId { get; set; }

    }

    /// <summary>
    /// Connection state snapshot.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionStateSnapshot
    {
        /// <summary>
        /// The connection state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionStateSnapshotConnectionState? ConnectionState { get; set; }

        /// <summary>
        /// The start time of the connection snapshot.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// The end time of the connection snapshot.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndTime { get; set; }

        /// <summary>
        /// Connectivity analysis evaluation state.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("evaluationState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionStateSnapshotEvaluationState? EvaluationState { get; set; }

        /// <summary>
        /// Average latency in ms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("avgLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? AvgLatencyInMs { get; set; }

        /// <summary>
        /// Minimum latency in ms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? MinLatencyInMs { get; set; }

        /// <summary>
        /// Maximum latency in ms.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxLatencyInMs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? MaxLatencyInMs { get; set; }

        /// <summary>
        /// The number of sent probes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probesSent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? ProbesSent { get; set; }

        /// <summary>
        /// The number of failed probes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probesFailed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? ProbesFailed { get; set; }

        /// <summary>
        /// List of hops between the source and the destination.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectivityHop2> Hops { get; set; }

    }

    /// <summary>
    /// List of connection monitors.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorListResult
    {
        /// <summary>
        /// Information about connection monitors.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionMonitorResult> Value { get; set; }

    }

    /// <summary>
    /// Information about the connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorResult
    {
        /// <summary>
        /// Name of the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// ID of the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Connection monitor type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// Connection monitor location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        /// <summary>
        /// Connection monitor tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        /// <summary>
        /// Properties of the connection monitor result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConnectionMonitorResultProperties Properties { get; set; }

    }

    /// <summary>
    /// Describes the properties of a connection monitor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorResultProperties : ConnectionMonitorParameters
    {
        /// <summary>
        /// The provisioning state of the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The date and time when the connection monitor was started.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// The monitoring status of the connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitoringStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MonitoringStatus { get; set; }

        /// <summary>
        /// Type of connection monitor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionMonitorType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorResultPropertiesConnectionMonitorType? ConnectionMonitorType { get; set; }

    }

    /// <summary>
    /// List of connection states snapshots.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorQueryResult
    {
        /// <summary>
        /// Status of connection monitor source.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ConnectionMonitorQueryResultSourceStatus? SourceStatus { get; set; }

        /// <summary>
        /// Information about connection states.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ConnectionStateSnapshot> States { get; set; }

    }

    /// <summary>
    /// Connection monitor endpoint location details only being used for 'AzureArcNetwork' type endpoints, which contains the region details.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectionMonitorEndpointLocationDetails
    {
        /// <summary>
        /// Region for connection monitor endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

    }

    /// <summary>
    /// Tags object for patch operations.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TagsObject
    {
        /// <summary>
        /// Resource tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Common error details representation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorDetails
    {
        /// <summary>
        /// Error code.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }

        /// <summary>
        /// Error target.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target { get; set; }

        /// <summary>
        /// Error message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Common resource representation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Resource
    {
        /// <summary>
        /// Resource ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Resource name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// Resource location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        /// <summary>
        /// Resource tags.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Tags { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The current provisioning state.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ProvisioningState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Succeeded")]
        Succeeded = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Updating")]
        Updating = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Deleting")]
        Deleting = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 3,

    }

    /// <summary>
    /// Reference to another subresource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubResource
    {
        /// <summary>
        /// Resource ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Access to be allowed or denied.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Access
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Allow")]
        Allow = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Deny")]
        Deny = 1,

    }

    /// <summary>
    /// An application security group in a resource group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationSecurityGroup : Resource
    {
        /// <summary>
        /// Properties of the application security group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Tap configuration in a Network Interface.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkInterfaceTapConfiguration : SubResource
    {
        /// <summary>
        /// Properties of the Virtual Network Tap configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties2 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Sub Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// IPConfiguration in a network interface.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkInterfaceIPConfiguration : SubResource
    {
        /// <summary>
        /// Network interface IP configuration properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties3 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// IP address allocation method.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IPAllocationMethod
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Static")]
        Static = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Dynamic")]
        Dynamic = 1,

    }

    /// <summary>
    /// IP address version.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IPVersion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"IPv4")]
        IPv4 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IPv6")]
        IPv6 = 1,

    }

    /// <summary>
    /// NetworkSecurityGroup resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkSecurityGroup : Resource
    {
        /// <summary>
        /// Properties of the network security group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties4 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Subnet in a virtual network resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Subnet : SubResource
    {
        /// <summary>
        /// Properties of the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties5 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Route table resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RouteTable : Resource
    {
        /// <summary>
        /// Properties of the route table.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties6 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Service End point policy resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceEndpointPolicy : Resource
    {
        /// <summary>
        /// Properties of the service end point policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties7 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Kind of service endpoint policy. This is metadata used for the Azure portal experience.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

    }

    /// <summary>
    /// ExtendedLocation complex type.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExtendedLocation
    {
        /// <summary>
        /// The name of the extended location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The type of the extended location.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Type? Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A network interface in a resource group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkInterface : Resource
    {
        /// <summary>
        /// The extended location of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extendedLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtendedLocation ExtendedLocation { get; set; }

        /// <summary>
        /// Properties of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties8 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Frontend IP address of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FrontendIPConfiguration : SubResource
    {
        /// <summary>
        /// Properties of the load balancer probe.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties9 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of frontend IP configurations used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A list of availability zones denoting the IP allocated for the resource needs to come from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zones", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Zones { get; set; }

    }

    /// <summary>
    /// Private endpoint resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateEndpoint : Resource
    {
        /// <summary>
        /// The extended location of the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extendedLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtendedLocation ExtendedLocation { get; set; }

        /// <summary>
        /// Properties of the private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties10 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// A collection of information about the state of the connection between service consumer and provider.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateLinkServiceConnectionState
    {
        /// <summary>
        /// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        /// <summary>
        /// The reason for approval/rejection of the connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A message indicating if changes on the service provider require any updates on the consumer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionsRequired", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionsRequired { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// IP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IPConfiguration : SubResource
    {
        /// <summary>
        /// Properties of the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties11 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// IP configuration profile child resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IPConfigurationProfile : SubResource
    {
        /// <summary>
        /// Properties of the IP configuration profile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties12 Properties { get; set; }

        /// <summary>
        /// The name of the resource. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Sub Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Identity for the resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManagedServiceIdentity
    {
        /// <summary>
        /// The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("principalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrincipalId { get; set; }

        /// <summary>
        /// The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TenantId { get; set; }

        /// <summary>
        /// The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ManagedServiceIdentityType? Type { get; set; }

        /// <summary>
        /// The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("userAssignedIdentities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, Anonymous> UserAssignedIdentities { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// IP configuration of an application gateway. Currently 1 public and 1 private IP configuration is allowed.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationGatewayIPConfiguration : SubResource
    {
        /// <summary>
        /// Properties of the application gateway IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties13 Properties { get; set; }

        /// <summary>
        /// Name of the IP configuration that is unique within an Application Gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// A flow log resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowLog2 : Resource
    {
        /// <summary>
        /// Properties of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties14 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// FlowLog resource Managed Identity
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManagedServiceIdentity Identity { get; set; }

    }

    /// <summary>
    /// Nat Gateway resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NatGateway : Resource
    {
        /// <summary>
        /// The nat gateway SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sku", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sku Sku { get; set; }

        /// <summary>
        /// Nat Gateway properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties15 Properties { get; set; }

        /// <summary>
        /// A list of availability zones denoting the zone in which Nat Gateway should be deployed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zones", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Zones { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Response for GetPublicIpAddressDdosProtectionStatusOperation API service call.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicIpDdosProtectionStatusResult
    {
        /// <summary>
        /// Public IP ARM resource ID
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIpAddressId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PublicIpAddressId { get; set; }

        /// <summary>
        /// IP Address of the Public IP Resource
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIpAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PublicIpAddress { get; set; }

        /// <summary>
        /// Value indicating whether the IP address is DDoS workload protected or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isWorkloadProtected", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PublicIpDdosProtectionStatusResultIsWorkloadProtected? IsWorkloadProtected { get; set; }

        /// <summary>
        ///  DDoS protection plan Resource Id of a if IP address is protected through a plan.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ddosProtectionPlanId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DdosProtectionPlanId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Public IP address resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicIPAddress : Resource
    {
        /// <summary>
        /// The extended location of the public ip address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extendedLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtendedLocation ExtendedLocation { get; set; }

        /// <summary>
        /// The public IP address SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sku", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sku2 Sku { get; set; }

        /// <summary>
        /// Public IP address properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties16 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// A list of availability zones denoting the IP allocated for the resource needs to come from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zones", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Zones { get; set; }

    }

    /// <summary>
    /// Virtual Network Tap resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VirtualNetworkTap : Resource
    {
        /// <summary>
        /// Virtual Network Tap Properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties17 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Backend Address Pool of an application gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApplicationGatewayBackendAddressPool : SubResource
    {
        /// <summary>
        /// Properties of the application gateway backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties18 Properties { get; set; }

        /// <summary>
        /// Name of the backend address pool that is unique within an Application Gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Pool of backend IP addresses.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BackendAddressPool : SubResource
    {
        /// <summary>
        /// Properties of load balancer backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties19 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of backend address pools used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Inbound NAT rule of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InboundNatRule : SubResource
    {
        /// <summary>
        /// Properties of load balancer inbound NAT rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties20 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of inbound NAT rules used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Private link service resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateLinkService : Resource
    {
        /// <summary>
        /// The extended location of the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extendedLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtendedLocation ExtendedLocation { get; set; }

        /// <summary>
        /// Properties of the private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties21 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// LoadBalancer resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoadBalancer : Resource
    {
        /// <summary>
        /// The extended location of the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("extendedLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtendedLocation ExtendedLocation { get; set; }

        /// <summary>
        /// The load balancer SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sku", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sku3 Sku { get; set; }

        /// <summary>
        /// Properties of load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties22 Properties { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Whether network traffic is allowed or denied.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SecurityRuleAccess
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Allow")]
        Allow = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Deny")]
        Deny = 1,

    }

    /// <summary>
    /// The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SecurityRuleDirection
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Inbound")]
        Inbound = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Outbound")]
        Outbound = 1,

    }

    /// <summary>
    /// The type of Azure hop the packet should be sent to.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RouteNextHopType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"VirtualNetworkGateway")]
        VirtualNetworkGateway = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"VnetLocal")]
        VnetLocal = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Internet")]
        Internet = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"VirtualAppliance")]
        VirtualAppliance = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 4,

    }

    /// <summary>
    /// Network security rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityRule : SubResource
    {
        /// <summary>
        /// Properties of the security rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties23 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// The type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Effective network security rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EffectiveNetworkSecurityRule
    {
        /// <summary>
        /// The name of the security rule specified by the user (if created by the user).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The network protocol this rule applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EffectiveNetworkSecurityRuleProtocol? Protocol { get; set; }

        /// <summary>
        /// The source port or range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourcePortRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourcePortRange { get; set; }

        /// <summary>
        /// The destination port or range.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationPortRange { get; set; }

        /// <summary>
        /// The source port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourcePortRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> SourcePortRanges { get; set; }

        /// <summary>
        /// The destination port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> DestinationPortRanges { get; set; }

        /// <summary>
        /// The source address prefix.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceAddressPrefix { get; set; }

        /// <summary>
        /// The destination address prefix.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationAddressPrefix { get; set; }

        /// <summary>
        /// The source address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceAddressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> SourceAddressPrefixes { get; set; }

        /// <summary>
        /// The destination address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationAddressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> DestinationAddressPrefixes { get; set; }

        /// <summary>
        /// The expanded source address prefix.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expandedSourceAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> ExpandedSourceAddressPrefix { get; set; }

        /// <summary>
        /// Expanded destination address prefix.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expandedDestinationAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> ExpandedDestinationAddressPrefix { get; set; }

        /// <summary>
        /// Whether network traffic is allowed or denied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityRuleAccess? Access { get; set; }

        /// <summary>
        /// The priority of the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        /// <summary>
        /// The direction of the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityRuleDirection? Direction { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Information about a hop between the source and the destination.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConnectivityHop2
    {
        /// <summary>
        /// The type of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// The ID of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The IP address of the hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>
        /// The ID of the resource corresponding to this hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        /// <summary>
        /// List of next hop identifiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> NextHopIds { get; set; }

        /// <summary>
        /// List of previous hop identifiers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousHopIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> PreviousHopIds { get; set; }

        /// <summary>
        /// List of hop links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Links> Links { get; set; }

        /// <summary>
        /// List of previous hop links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("previousLinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Links> PreviousLinks { get; set; }

        /// <summary>
        /// List of issues.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Issues> Issues { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The error object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorResponse2
    {
        /// <summary>
        /// The error details object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDetails Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TopologyAssociationAssociationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Associated")]
        Associated = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Contains")]
        Contains = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum VerificationIPFlowParametersProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NextHopResultNextHopType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Internet")]
        Internet = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"VirtualAppliance")]
        VirtualAppliance = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"VirtualNetworkGateway")]
        VirtualNetworkGateway = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"VnetLocal")]
        VnetLocal = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"HyperNetGateway")]
        HyperNetGateway = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PacketCaptureParametersTargetType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AzureVM")]
        AzureVM = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureVMSS")]
        AzureVMSS = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PacketCaptureFilterProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Any")]
        Any = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PacketCaptureQueryStatusResultPacketCaptureStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NotStarted")]
        NotStarted = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Running")]
        Running = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Stopped")]
        Stopped = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PacketCaptureError
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InternalError")]
        InternalError = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AgentStopped")]
        AgentStopped = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CaptureFailed")]
        CaptureFailed = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"LocalFileFailed")]
        LocalFileFailed = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"StorageFailed")]
        StorageFailed = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FlowLogFormatParametersType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"JSON")]
        JSON = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectivityParametersProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Http")]
        Http = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Https")]
        Https = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Icmp")]
        Icmp = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectivityInformationConnectionStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Connected")]
        Connected = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Disconnected")]
        Disconnected = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Degraded")]
        Degraded = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectivityIssueOrigin
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Local")]
        Local = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Inbound")]
        Inbound = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Outbound")]
        Outbound = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectivityIssueSeverity
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Warning")]
        Warning = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectivityIssueType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AgentStopped")]
        AgentStopped = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"GuestFirewall")]
        GuestFirewall = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"DnsResolution")]
        DnsResolution = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"SocketBind")]
        SocketBind = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"NetworkSecurityRule")]
        NetworkSecurityRule = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"UserDefinedRoute")]
        UserDefinedRoute = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PortThrottled")]
        PortThrottled = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"Platform")]
        Platform = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HTTPConfigurationMethod
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Get")]
        Get = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NetworkConfigurationDiagnosticParametersVerbosityLevel
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Normal")]
        Normal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Full")]
        Full = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorEndpointType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AzureVM")]
        AzureVM = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureVNet")]
        AzureVNet = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureSubnet")]
        AzureSubnet = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ExternalAddress")]
        ExternalAddress = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"MMAWorkspaceMachine")]
        MMAWorkspaceMachine = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"MMAWorkspaceNetwork")]
        MMAWorkspaceNetwork = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureArcVM")]
        AzureArcVM = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureVMSS")]
        AzureVMSS = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureArcNetwork")]
        AzureArcNetwork = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorEndpointCoverageLevel
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Low")]
        Low = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"BelowAverage")]
        BelowAverage = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Average")]
        Average = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"AboveAverage")]
        AboveAverage = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Full")]
        Full = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorEndpointFilterType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Include")]
        Include = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorEndpointFilterItemType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AgentAddress")]
        AgentAddress = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorTestConfigurationProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Http")]
        Http = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Icmp")]
        Icmp = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorTestConfigurationPreferredIPVersion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"IPv4")]
        IPv4 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IPv6")]
        IPv6 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorHttpConfigurationMethod
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Get")]
        Get = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Post")]
        Post = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorTcpConfigurationDestinationPortBehavior
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ListenIfAvailable")]
        ListenIfAvailable = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorOutputType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Workspace")]
        Workspace = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionStateSnapshotConnectionState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Reachable")]
        Reachable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Unreachable")]
        Unreachable = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionStateSnapshotEvaluationState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NotStarted")]
        NotStarted = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InProgress")]
        InProgress = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Completed")]
        Completed = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorResultPropertiesConnectionMonitorType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"MultiEndpoint")]
        MultiEndpoint = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SingleSourceDestination")]
        SingleSourceDestination = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ConnectionMonitorQueryResultSourceStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Inactive")]
        Inactive = 2,

    }

    /// <summary>
    /// Application security group properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties
    {
        /// <summary>
        /// The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the application security group resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of Virtual Network Tap configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties2
    {
        /// <summary>
        /// The reference to the Virtual Network Tap resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtualNetworkTap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VirtualNetworkTap VirtualNetworkTap { get; set; }

        /// <summary>
        /// The provisioning state of the network interface tap configuration resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of IP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties3
    {
        /// <summary>
        /// The reference to gateway load balancer frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gatewayLoadBalancer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource GatewayLoadBalancer { get; set; }

        /// <summary>
        /// The reference to Virtual Network Taps.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtualNetworkTaps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<VirtualNetworkTap> VirtualNetworkTaps { get; set; }

        /// <summary>
        /// The reference to ApplicationGatewayBackendAddressPool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applicationGatewayBackendAddressPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationGatewayBackendAddressPool> ApplicationGatewayBackendAddressPools { get; set; }

        /// <summary>
        /// The reference to LoadBalancerBackendAddressPool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancerBackendAddressPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<BackendAddressPool> LoadBalancerBackendAddressPools { get; set; }

        /// <summary>
        /// A list of references of LoadBalancerInboundNatRules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancerInboundNatRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<InboundNatRule> LoadBalancerInboundNatRules { get; set; }

        /// <summary>
        /// Private IP address of the IP configuration. It can be a single IP address or a CIDR block in the format &lt;address&gt;/&lt;prefix-length&gt;.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateIPAddress { get; set; }

        /// <summary>
        /// The private IP address prefix length. If specified and the allocation method is dynamic, the service will allocate a CIDR block instead of a single IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddressPrefixLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, 128)]
        public int? PrivateIPAddressPrefixLength { get; set; }

        /// <summary>
        /// The private IP address allocation method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAllocationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPAllocationMethod? PrivateIPAllocationMethod { get; set; }

        /// <summary>
        /// Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddressVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPVersion? PrivateIPAddressVersion { get; set; }

        /// <summary>
        /// Subnet bound to the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// Whether this is a primary customer address on the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primary { get; set; }

        /// <summary>
        /// Public IP address bound to the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicIPAddress PublicIPAddress { get; set; }

        /// <summary>
        /// Application security groups in which the IP configuration is included.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applicationSecurityGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationSecurityGroup> ApplicationSecurityGroups { get; set; }

        /// <summary>
        /// The provisioning state of the network interface IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// PrivateLinkConnection properties for the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkConnectionProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateLinkConnectionProperties PrivateLinkConnectionProperties { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Network Security Group resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties4
    {
        /// <summary>
        /// When enabled, flows created from Network Security Group connections will be re-evaluated when rules are updates. Initial enablement will trigger re-evaluation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flushConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FlushConnection { get; set; }

        /// <summary>
        /// A collection of security rules of the network security group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityRule> SecurityRules { get; set; }

        /// <summary>
        /// The default security rules of network security group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultSecurityRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SecurityRule> DefaultSecurityRules { get; set; }

        /// <summary>
        /// A collection of references to network interfaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterface> NetworkInterfaces { get; set; }

        /// <summary>
        /// A collection of references to subnets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Subnet> Subnets { get; set; }

        /// <summary>
        /// A collection of references to flow log resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flowLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FlowLog2> FlowLogs { get; set; }

        /// <summary>
        /// The resource GUID property of the network security group resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the network security group resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the subnet.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties5
    {
        /// <summary>
        /// The address prefix for the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AddressPrefix { get; set; }

        /// <summary>
        /// List of address prefixes for the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> AddressPrefixes { get; set; }

        /// <summary>
        /// The reference to the NetworkSecurityGroup resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkSecurityGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkSecurityGroup NetworkSecurityGroup { get; set; }

        /// <summary>
        /// The reference to the RouteTable resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routeTable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RouteTable RouteTable { get; set; }

        /// <summary>
        /// Nat gateway associated with this subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("natGateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource NatGateway { get; set; }

        /// <summary>
        /// An array of service endpoints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceEndpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ServiceEndpoints> ServiceEndpoints { get; set; }

        /// <summary>
        /// An array of service endpoint policies.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceEndpointPolicies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ServiceEndpointPolicy> ServiceEndpointPolicies { get; set; }

        /// <summary>
        /// An array of references to private endpoints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PrivateEndpoint> PrivateEndpoints { get; set; }

        /// <summary>
        /// An array of references to the network interface IP configurations using subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IPConfiguration> IpConfigurations { get; set; }

        /// <summary>
        /// Array of IP configuration profiles which reference this subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfigurationProfiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IPConfigurationProfile> IpConfigurationProfiles { get; set; }

        /// <summary>
        /// Array of IpAllocation which reference this subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> IpAllocations { get; set; }

        /// <summary>
        /// An array of references to the external resources using subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceNavigationLinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ResourceNavigationLinks> ResourceNavigationLinks { get; set; }

        /// <summary>
        /// An array of references to services injecting into this subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAssociationLinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ServiceAssociationLinks> ServiceAssociationLinks { get; set; }

        /// <summary>
        /// An array of references to the delegations on the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("delegations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Delegations> Delegations { get; set; }

        /// <summary>
        /// A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("purpose", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Purpose { get; set; }

        /// <summary>
        /// The provisioning state of the subnet resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// Enable or Disable apply network policies on private end point in the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpointNetworkPolicies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties5PrivateEndpointNetworkPolicies? PrivateEndpointNetworkPolicies { get; set; } = NetworkWatcherController.Properties5PrivateEndpointNetworkPolicies.Disabled;

        /// <summary>
        /// Enable or Disable apply network policies on private link service in the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkServiceNetworkPolicies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties5PrivateLinkServiceNetworkPolicies? PrivateLinkServiceNetworkPolicies { get; set; } = NetworkWatcherController.Properties5PrivateLinkServiceNetworkPolicies.Enabled;

        /// <summary>
        /// Application gateway IP configurations of virtual network resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applicationGatewayIPConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationGatewayIPConfiguration> ApplicationGatewayIPConfigurations { get; set; }

        /// <summary>
        /// Set this property to Tenant to allow sharing subnet with other subscriptions in your AAD tenant. This property can only be set if defaultOutboundAccess is set to false, both properties can only be set if subnet is empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sharingScope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties5SharingScope? SharingScope { get; set; }

        /// <summary>
        /// Set this property to false to disable default outbound connectivity for all VMs in the subnet. This property can only be set at the time of subnet creation and cannot be updated for an existing subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultOutboundAccess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DefaultOutboundAccess { get; set; }

        /// <summary>
        /// A list of IPAM Pools for allocating IP address prefixes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipamPoolPrefixAllocations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IpamPoolPrefixAllocations> IpamPoolPrefixAllocations { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Route Table resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties6
    {
        /// <summary>
        /// Collection of routes contained within a route table.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Routes> Routes { get; set; }

        /// <summary>
        /// A collection of references to subnets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Subnet> Subnets { get; set; }

        /// <summary>
        /// Whether to disable the routes learned by BGP on that route table. True means disable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableBgpRoutePropagation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableBgpRoutePropagation { get; set; }

        /// <summary>
        /// The provisioning state of the route table resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The resource GUID property of the route table.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Service Endpoint Policy resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties7
    {
        /// <summary>
        /// A collection of service endpoint policy definitions of the service endpoint policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceEndpointPolicyDefinitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ServiceEndpointPolicyDefinitions> ServiceEndpointPolicyDefinitions { get; set; }

        /// <summary>
        /// A collection of references to subnets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Subnet> Subnets { get; set; }

        /// <summary>
        /// The resource GUID property of the service endpoint policy resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the service endpoint policy resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The alias indicating if the policy belongs to a service
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAlias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAlias { get; set; }

        /// <summary>
        /// A collection of contextual service endpoint policy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextualServiceEndpointPolicies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> ContextualServiceEndpointPolicies { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The supported ExtendedLocation types. Currently only EdgeZone is supported in Microsoft.Network resources.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EdgeZone")]
        EdgeZone = 0,

    }

    /// <summary>
    /// NetworkInterface properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties8
    {
        /// <summary>
        /// The reference to a virtual machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtualMachine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource VirtualMachine { get; set; }

        /// <summary>
        /// The reference to the NetworkSecurityGroup resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkSecurityGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkSecurityGroup NetworkSecurityGroup { get; set; }

        /// <summary>
        /// A reference to the private endpoint to which the network interface is linked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateEndpoint PrivateEndpoint { get; set; }

        /// <summary>
        /// A list of IPConfigurations of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterfaceIPConfiguration> IpConfigurations { get; set; }

        /// <summary>
        /// A list of TapConfigurations of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tapConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterfaceTapConfiguration> TapConfigurations { get; set; }

        /// <summary>
        /// The DNS settings in network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dnsSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DnsSettings DnsSettings { get; set; }

        /// <summary>
        /// The MAC address of the network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("macAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MacAddress { get; set; }

        /// <summary>
        /// Whether this is a primary network interface on a virtual machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primary { get; set; }

        /// <summary>
        /// Whether the virtual machine this nic is attached to supports encryption.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vnetEncryptionSupported", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? VnetEncryptionSupported { get; set; }

        /// <summary>
        /// Whether default outbound connectivity for nic was configured or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultOutboundConnectivityEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DefaultOutboundConnectivityEnabled { get; set; }

        /// <summary>
        /// If the network interface is configured for accelerated networking. Not applicable to VM sizes which require accelerated networking.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableAcceleratedNetworking", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableAcceleratedNetworking { get; set; }

        /// <summary>
        /// Indicates whether to disable tcp state tracking.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableTcpStateTracking", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableTcpStateTracking { get; set; }

        /// <summary>
        /// Indicates whether IP forwarding is enabled on this network interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableIPForwarding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableIPForwarding { get; set; }

        /// <summary>
        /// A list of references to linked BareMetal resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostedWorkloads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> HostedWorkloads { get; set; }

        /// <summary>
        /// A reference to the dscp configuration to which the network interface is linked.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dscpConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource DscpConfiguration { get; set; }

        /// <summary>
        /// The resource GUID property of the network interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the network interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// WorkloadType of the NetworkInterface for BareMetal resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workloadType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkloadType { get; set; }

        /// <summary>
        /// Type of Network Interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nicType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties8NicType? NicType { get; set; }

        /// <summary>
        /// Privatelinkservice of the network interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkService", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateLinkService PrivateLinkService { get; set; }

        /// <summary>
        /// Migration phase of Network Interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("migrationPhase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties8MigrationPhase? MigrationPhase { get; set; }

        /// <summary>
        /// Auxiliary mode of Network Interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auxiliaryMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties8AuxiliaryMode? AuxiliaryMode { get; set; }

        /// <summary>
        /// Auxiliary sku of Network Interface resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auxiliarySku", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties8AuxiliarySku? AuxiliarySku { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of Frontend IP Configuration of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties9
    {
        /// <summary>
        /// An array of references to inbound rules that use this frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> InboundNatRules { get; set; }

        /// <summary>
        /// An array of references to inbound pools that use this frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> InboundNatPools { get; set; }

        /// <summary>
        /// An array of references to outbound rules that use this frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> OutboundRules { get; set; }

        /// <summary>
        /// An array of references to load balancing rules that use this frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancingRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> LoadBalancingRules { get; set; }

        /// <summary>
        /// The private IP address of the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateIPAddress { get; set; }

        /// <summary>
        /// The Private IP allocation method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAllocationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPAllocationMethod? PrivateIPAllocationMethod { get; set; }

        /// <summary>
        /// Whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddressVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPVersion? PrivateIPAddressVersion { get; set; }

        /// <summary>
        /// The reference to the subnet resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// The reference to the Public IP resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicIPAddress PublicIPAddress { get; set; }

        /// <summary>
        /// The reference to the Public IP Prefix resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource PublicIPPrefix { get; set; }

        /// <summary>
        /// The reference to gateway load balancer frontend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gatewayLoadBalancer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource GatewayLoadBalancer { get; set; }

        /// <summary>
        /// The provisioning state of the frontend IP configuration resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the private endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties10
    {
        /// <summary>
        /// The ID of the subnet from which the private IP will be allocated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// An array of references to the network interfaces created for this private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterface> NetworkInterfaces { get; set; }

        /// <summary>
        /// The provisioning state of the private endpoint resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// A grouping of information about the connection to the remote resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkServiceConnections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PrivateLinkServiceConnections> PrivateLinkServiceConnections { get; set; }

        /// <summary>
        /// A grouping of information about the connection to the remote resource. Used when the network admin does not have access to approve connections to the remote resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manualPrivateLinkServiceConnections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PrivateLinkServiceConnections> ManualPrivateLinkServiceConnections { get; set; }

        /// <summary>
        /// An array of custom dns configurations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customDnsConfigs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<CustomDnsConfigs> CustomDnsConfigs { get; set; }

        /// <summary>
        /// Application security groups in which the private endpoint IP configuration is included.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("applicationSecurityGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationSecurityGroup> ApplicationSecurityGroups { get; set; }

        /// <summary>
        /// A list of IP configurations of the private endpoint. This will be used to map to the First Party Service's endpoints.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IpConfigurations> IpConfigurations { get; set; }

        /// <summary>
        /// The custom name of the network interface attached to the private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customNetworkInterfaceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomNetworkInterfaceName { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of IP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties11
    {
        /// <summary>
        /// The private IP address of the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateIPAddress { get; set; }

        /// <summary>
        /// The private IP address allocation method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAllocationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPAllocationMethod? PrivateIPAllocationMethod { get; set; } = NetworkWatcherController.IPAllocationMethod.Dynamic;

        /// <summary>
        /// The reference to the subnet resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// The reference to the public IP resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicIPAddress PublicIPAddress { get; set; }

        /// <summary>
        /// The provisioning state of the IP configuration resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// IP configuration profile properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties12
    {
        /// <summary>
        /// The reference to the subnet resource to create a container network interface ip configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// The provisioning state of the IP configuration profile resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ManagedServiceIdentityType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SystemAssigned")]
        SystemAssigned = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"UserAssigned")]
        UserAssigned = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SystemAssigned, UserAssigned")]
        SystemAssigned__UserAssigned = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Anonymous
    {
        /// <summary>
        /// The principal id of user assigned identity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("principalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrincipalId { get; set; }

        /// <summary>
        /// The client id of user assigned identity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clientId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of IP configuration of an application gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties13
    {
        /// <summary>
        /// Reference to the subnet resource. A subnet from where application gateway gets its private address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource Subnet { get; set; }

        /// <summary>
        /// The provisioning state of the application gateway IP configuration resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Parameters that define the configuration of flow log.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties14
    {
        /// <summary>
        /// ID of network security group to which flow log will be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetResourceId { get; set; }

        /// <summary>
        /// Guid of network security group to which flow log will be applied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetResourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetResourceGuid { get; set; }

        /// <summary>
        /// ID of the storage account which is used to store the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StorageId { get; set; }

        /// <summary>
        /// Optional field to filter network traffic logs based on SrcIP, SrcPort, DstIP, DstPort, Protocol, Encryption, Direction and Action. If not specified, all network traffic will be logged.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabledFilteringCriteria", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EnabledFilteringCriteria { get; set; }

        /// <summary>
        /// Flag to enable/disable flow logging.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// Parameters that define the retention policy for flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retentionPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetentionPolicy RetentionPolicy { get; set; }

        /// <summary>
        /// Parameters that define the flow log format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Format Format { get; set; }

        /// <summary>
        /// Parameters that define the configuration of traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flowAnalyticsConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlowAnalyticsConfiguration FlowAnalyticsConfiguration { get; set; }

        /// <summary>
        /// The provisioning state of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// SKU of nat gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sku
    {
        /// <summary>
        /// Name of Nat Gateway SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SkuName? Name { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Nat Gateway properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties15
    {
        /// <summary>
        /// The idle timeout of the nat gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        /// <summary>
        /// An array of public ip addresses associated with the nat gateway resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIpAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> PublicIpAddresses { get; set; }

        /// <summary>
        /// An array of public ip prefixes associated with the nat gateway resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIpPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> PublicIpPrefixes { get; set; }

        /// <summary>
        /// An array of references to the subnets using this nat gateway resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> Subnets { get; set; }

        /// <summary>
        /// The resource GUID property of the NAT gateway resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the NAT gateway resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PublicIpDdosProtectionStatusResultIsWorkloadProtected
    {

        [System.Runtime.Serialization.EnumMember(Value = @"False")]
        False = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"True")]
        True = 1,

    }

    /// <summary>
    /// SKU of a public IP address.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sku2
    {
        /// <summary>
        /// Name of a public IP address SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Sku2Name? Name { get; set; }

        /// <summary>
        /// Tier of a public IP address SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Sku2Tier? Tier { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Public IP address properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties16
    {
        /// <summary>
        /// The public IP address allocation method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPAllocationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPAllocationMethod? PublicIPAllocationMethod { get; set; }

        /// <summary>
        /// The public IP address version.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPAddressVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPVersion? PublicIPAddressVersion { get; set; }

        /// <summary>
        /// The IP configuration associated with the public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IPConfiguration IpConfiguration { get; set; }

        /// <summary>
        /// The FQDN of the DNS record associated with the public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dnsSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DnsSettings2 DnsSettings { get; set; }

        /// <summary>
        /// The DDoS protection custom policy associated with the public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ddosSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DdosSettings DdosSettings { get; set; }

        /// <summary>
        /// The list of tags associated with the public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<IpTags> IpTags { get; set; }

        /// <summary>
        /// The IP address associated with the public IP address resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IpAddress { get; set; }

        /// <summary>
        /// The Public IP Prefix this Public IP Address should be allocated from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("publicIPPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource PublicIPPrefix { get; set; }

        /// <summary>
        /// The idle timeout of the public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        /// <summary>
        /// The resource GUID property of the public IP address resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the public IP address resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The service public IP address of the public IP address resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("servicePublicIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicIPAddress ServicePublicIPAddress { get; set; }

        /// <summary>
        /// The NatGateway for the Public IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("natGateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NatGateway NatGateway { get; set; }

        /// <summary>
        /// Migration phase of Public IP Address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("migrationPhase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties16MigrationPhase? MigrationPhase { get; set; }

        /// <summary>
        /// The linked public IP address of the public IP address resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkedPublicIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PublicIPAddress LinkedPublicIPAddress { get; set; }

        /// <summary>
        /// Specify what happens to the public IP address when the VM using it is deleted
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deleteOption", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties16DeleteOption? DeleteOption { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Virtual Network Tap properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties17
    {
        /// <summary>
        /// Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaceTapConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterfaceTapConfiguration> NetworkInterfaceTapConfigurations { get; set; }

        /// <summary>
        /// The resource GUID property of the virtual network tap resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the virtual network tap resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The reference to the private IP Address of the collector nic that will receive the tap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationNetworkInterfaceIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkInterfaceIPConfiguration DestinationNetworkInterfaceIPConfiguration { get; set; }

        /// <summary>
        /// The reference to the private IP address on the internal Load Balancer that will receive the tap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationLoadBalancerFrontEndIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FrontendIPConfiguration DestinationLoadBalancerFrontEndIPConfiguration { get; set; }

        /// <summary>
        /// The VXLAN destination port that will receive the tapped traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DestinationPort { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of Backend Address Pool of an application gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties18
    {
        /// <summary>
        /// Collection of references to IPs defined in network interfaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendIPConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterfaceIPConfiguration> BackendIPConfigurations { get; set; }

        /// <summary>
        /// Backend addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<BackendAddresses> BackendAddresses { get; set; }

        /// <summary>
        /// The provisioning state of the backend address pool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the backend address pool.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties19
    {
        /// <summary>
        /// The location of the backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        /// <summary>
        /// An array of gateway load balancer tunnel interfaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tunnelInterfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<TunnelInterfaces> TunnelInterfaces { get; set; }

        /// <summary>
        /// An array of backend addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancerBackendAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LoadBalancerBackendAddresses> LoadBalancerBackendAddresses { get; set; }

        /// <summary>
        /// An array of references to IP addresses defined in network interfaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendIPConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterfaceIPConfiguration> BackendIPConfigurations { get; set; }

        /// <summary>
        /// An array of references to load balancing rules that use this backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancingRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> LoadBalancingRules { get; set; }

        /// <summary>
        /// A reference to an outbound rule that uses this backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundRule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource OutboundRule { get; set; }

        /// <summary>
        /// An array of references to outbound rules that use this backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> OutboundRules { get; set; }

        /// <summary>
        /// An array of references to inbound NAT rules that use this backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> InboundNatRules { get; set; }

        /// <summary>
        /// The provisioning state of the backend address pool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// Amount of seconds Load Balancer waits for before sending RESET to client and backend address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("drainPeriodInSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DrainPeriodInSeconds { get; set; }

        /// <summary>
        /// A reference to a virtual network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtualNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource VirtualNetwork { get; set; }

        /// <summary>
        /// Backend address synchronous mode for the backend pool
        /// </summary>
        [Newtonsoft.Json.JsonProperty("syncMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties19SyncMode? SyncMode { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the inbound NAT rule.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties20
    {
        /// <summary>
        /// A reference to frontend IP addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource FrontendIPConfiguration { get; set; }

        /// <summary>
        /// A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkInterfaceIPConfiguration BackendIPConfiguration { get; set; }

        /// <summary>
        /// The reference to the transport protocol used by the load balancing rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Protocol? Protocol { get; set; }

        /// <summary>
        /// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FrontendPort { get; set; }

        /// <summary>
        /// The port used for the internal endpoint. Acceptable values range from 1 to 65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BackendPort { get; set; }

        /// <summary>
        /// The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        /// <summary>
        /// Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableFloatingIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableFloatingIP { get; set; }

        /// <summary>
        /// Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableTcpReset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableTcpReset { get; set; }

        /// <summary>
        /// The port range start for the external endpoint. This property is used together with BackendAddressPool and FrontendPortRangeEnd. Individual inbound NAT rule port mappings will be created for each backend address from BackendAddressPool. Acceptable values range from 1 to 65534.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPortRangeStart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FrontendPortRangeStart { get; set; }

        /// <summary>
        /// The port range end for the external endpoint. This property is used together with BackendAddressPool and FrontendPortRangeStart. Individual inbound NAT rule port mappings will be created for each backend address from BackendAddressPool. Acceptable values range from 1 to 65534.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPortRangeEnd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FrontendPortRangeEnd { get; set; }

        /// <summary>
        /// A reference to backendAddressPool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddressPool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource BackendAddressPool { get; set; }

        /// <summary>
        /// The provisioning state of the inbound NAT rule resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the private link service.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties21
    {
        /// <summary>
        /// An array of references to the load balancer IP configurations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancerFrontendIpConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FrontendIPConfiguration> LoadBalancerFrontendIpConfigurations { get; set; }

        /// <summary>
        /// An array of private link service IP configurations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ipConfigurations> IpConfigurations { get; set; }

        /// <summary>
        /// The destination IP address of the private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationIPAddress { get; set; }

        /// <summary>
        /// An array of references to the network interfaces created for this private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<NetworkInterface> NetworkInterfaces { get; set; }

        /// <summary>
        /// The provisioning state of the private link service resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// An array of list about connections to the private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpointConnections", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<PrivateEndpointConnections> PrivateEndpointConnections { get; set; }

        /// <summary>
        /// The visibility list of the private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("visibility", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Visibility Visibility { get; set; }

        /// <summary>
        /// The auto-approval list of the private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("autoApproval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Visibility AutoApproval { get; set; }

        /// <summary>
        /// The list of Fqdn.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Fqdns { get; set; }

        /// <summary>
        /// The alias of the private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }

        /// <summary>
        /// Whether the private link service is enabled for proxy protocol or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableProxyProtocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableProxyProtocol { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// SKU of a load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sku3
    {
        /// <summary>
        /// Name of a load balancer SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Sku3Name? Name { get; set; }

        /// <summary>
        /// Tier of a load balancer SKU.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Sku3Tier? Tier { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties22
    {
        /// <summary>
        /// Object representing the frontend IPs to be used for the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendIPConfigurations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<FrontendIPConfiguration> FrontendIPConfigurations { get; set; }

        /// <summary>
        /// Collection of backend address pools used by a load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddressPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<BackendAddressPool> BackendAddressPools { get; set; }

        /// <summary>
        /// Object collection representing the load balancing rules Gets the provisioning.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancingRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<LoadBalancingRules> LoadBalancingRules { get; set; }

        /// <summary>
        /// Collection of probe objects used in the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Probes> Probes { get; set; }

        /// <summary>
        /// Collection of inbound NAT Rules used by a load balancer. Defining inbound NAT rules on your load balancer is mutually exclusive with defining an inbound NAT pool. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an Inbound NAT pool. They have to reference individual inbound NAT rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<InboundNatRule> InboundNatRules { get; set; }

        /// <summary>
        /// Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer. Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external port from this range. Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound NAT rules. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an inbound NAT pool. They have to reference individual inbound NAT rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<InboundNatPools> InboundNatPools { get; set; }

        /// <summary>
        /// The outbound rules.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<OutboundRules> OutboundRules { get; set; }

        /// <summary>
        /// The resource GUID property of the load balancer resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceGuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceGuid { get; set; }

        /// <summary>
        /// The provisioning state of the load balancer resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Security rule resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties23
    {
        /// <summary>
        /// A description for this rule. Restricted to 140 chars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Network protocol this rule applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties23Protocol Protocol { get; set; }

        /// <summary>
        /// The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourcePortRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourcePortRange { get; set; }

        /// <summary>
        /// The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationPortRange { get; set; }

        /// <summary>
        /// The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SourceAddressPrefix { get; set; }

        /// <summary>
        /// The CIDR or source IP ranges.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceAddressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> SourceAddressPrefixes { get; set; }

        /// <summary>
        /// The application security group specified as source.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourceApplicationSecurityGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationSecurityGroup> SourceApplicationSecurityGroups { get; set; }

        /// <summary>
        /// The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationAddressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DestinationAddressPrefix { get; set; }

        /// <summary>
        /// The destination address prefixes. CIDR or destination IP ranges.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationAddressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> DestinationAddressPrefixes { get; set; }

        /// <summary>
        /// The application security group specified as destination.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationApplicationSecurityGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<ApplicationSecurityGroup> DestinationApplicationSecurityGroups { get; set; }

        /// <summary>
        /// The source port ranges.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sourcePortRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> SourcePortRanges { get; set; }

        /// <summary>
        /// The destination port ranges.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("destinationPortRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> DestinationPortRanges { get; set; }

        /// <summary>
        /// The network traffic is allowed or denied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityRuleAccess Access { get; set; }

        /// <summary>
        /// The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Always)]
        public int Priority { get; set; }

        /// <summary>
        /// The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("direction", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SecurityRuleDirection Direction { get; set; }

        /// <summary>
        /// The provisioning state of the security rule resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EffectiveNetworkSecurityRuleProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Udp")]
        Udp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"All")]
        All = 2,

    }

    /// <summary>
    /// Hop link.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Links
    {
        /// <summary>
        /// The ID of the next hop.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextHopId { get; set; }

        /// <summary>
        /// Link type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkType { get; set; }

        /// <summary>
        /// Hop link properties.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties24 Properties { get; set; }

        /// <summary>
        /// List of issues.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Issues> Issues { get; set; }

        /// <summary>
        /// Provides additional context on links.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Context { get; set; }

        /// <summary>
        /// Resource ID.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceId { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Information about an issue encountered in the process of checking for connectivity.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Issues
    {
        /// <summary>
        /// The origin of the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("origin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IssuesOrigin? Origin { get; set; }

        /// <summary>
        /// The severity of the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IssuesSeverity? Severity { get; set; }

        /// <summary>
        /// The type of issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IssuesType? Type { get; set; }

        /// <summary>
        /// Provides additional context on the issue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Context> Context { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// PrivateLinkConnection properties for the network interface.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateLinkConnectionProperties
    {
        /// <summary>
        /// The group ID for current private link connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupId { get; set; }

        /// <summary>
        /// The required member name for current private link connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requiredMemberName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RequiredMemberName { get; set; }

        /// <summary>
        /// List of FQDNs for current private link connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Fqdns { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// The service endpoint properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceEndpoints
    {
        /// <summary>
        /// The type of the endpoint service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service { get; set; }

        /// <summary>
        /// SubResource as network identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource NetworkIdentifier { get; set; }

        /// <summary>
        /// A list of locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Locations { get; set; }

        /// <summary>
        /// The provisioning state of the service endpoint resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// ResourceNavigationLink resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceNavigationLinks : SubResource
    {
        /// <summary>
        /// Resource navigation link properties format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties25 Properties { get; set; }

        /// <summary>
        /// Name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Resource navigation link identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// ServiceAssociationLink resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceAssociationLinks : SubResource
    {
        /// <summary>
        /// Resource navigation link properties format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties26 Properties { get; set; }

        /// <summary>
        /// Name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Details the service to which the subnet is delegated.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Delegations : SubResource
    {
        /// <summary>
        /// Properties of the subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties27 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a subnet. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties5PrivateEndpointNetworkPolicies
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NetworkSecurityGroupEnabled")]
        NetworkSecurityGroupEnabled = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RouteTableEnabled")]
        RouteTableEnabled = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties5PrivateLinkServiceNetworkPolicies
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties5SharingScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tenant")]
        Tenant = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DelegatedServices")]
        DelegatedServices = 1,

    }

    /// <summary>
    /// IpamPool prefix allocation reference.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IpamPoolPrefixAllocations
    {
        [Newtonsoft.Json.JsonProperty("pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pool Pool { get; set; }

        /// <summary>
        /// Number of IP addresses to allocate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("numberOfIpAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NumberOfIpAddresses { get; set; }

        /// <summary>
        /// List of assigned IP address prefixes in the IpamPool of the associated resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allocatedAddressPrefixes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> AllocatedAddressPrefixes { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Route resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routes : SubResource
    {
        /// <summary>
        /// Properties of the route.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties28 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// The type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Service Endpoint policy definitions.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceEndpointPolicyDefinitions : SubResource
    {
        /// <summary>
        /// Properties of the service endpoint policy definition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties29 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// The type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// DNS settings of a network interface.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DnsSettings
    {
        /// <summary>
        /// List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dnsServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> DnsServers { get; set; }

        /// <summary>
        /// If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appliedDnsServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> AppliedDnsServers { get; set; }

        /// <summary>
        /// Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internalDnsNameLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InternalDnsNameLabel { get; set; }

        /// <summary>
        /// Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internalFqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InternalFqdn { get; set; }

        /// <summary>
        /// Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("internalDomainNameSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InternalDomainNameSuffix { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties8NicType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Elastic")]
        Elastic = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties8MigrationPhase
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Prepare")]
        Prepare = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Commit")]
        Commit = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Abort")]
        Abort = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Committed")]
        Committed = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties8AuxiliaryMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MaxConnections")]
        MaxConnections = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Floating")]
        Floating = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"AcceleratedConnections")]
        AcceleratedConnections = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties8AuxiliarySku
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"A1")]
        A1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"A2")]
        A2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"A4")]
        A4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"A8")]
        A8 = 4,

    }

    /// <summary>
    /// PrivateLinkServiceConnection resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateLinkServiceConnections : SubResource
    {
        /// <summary>
        /// Properties of the private link service connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties30 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// Contains custom Dns resolution configuration from customer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CustomDnsConfigs
    {
        /// <summary>
        /// Fqdn that resolves to private endpoint ip address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }

        /// <summary>
        /// A list of private ip addresses of the private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> IpAddresses { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// An IP Configuration of the private endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IpConfigurations
    {
        /// <summary>
        /// Properties of private endpoint IP configurations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties31 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Parameters that define the retention policy for flow log.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetentionPolicy
    {
        /// <summary>
        /// Number of days to retain flow log records.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("days", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Days { get; set; } = 0;

        /// <summary>
        /// Flag to enable/disable retention.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = false;

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Parameters that define the flow log format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Format
    {
        /// <summary>
        /// The file type of flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FormatType? Type { get; set; }

        /// <summary>
        /// The version (revision) of the flow log.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Version { get; set; } = 0;

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Parameters that define the configuration of traffic analytics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlowAnalyticsConfiguration
    {
        /// <summary>
        /// Parameters that define the configuration of traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkWatcherFlowAnalyticsConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NetworkWatcherFlowAnalyticsConfiguration NetworkWatcherFlowAnalyticsConfiguration { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SkuName
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Sku2Name
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Basic")]
        Basic = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Sku2Tier
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Regional")]
        Regional = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Global")]
        Global = 1,

    }

    /// <summary>
    /// Contains FQDN of the DNS record associated with the public IP address.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DnsSettings2
    {
        /// <summary>
        /// The domain name label. The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domainNameLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DomainNameLabel { get; set; }

        /// <summary>
        /// The domain name label scope. If a domain name label and a domain name label scope are specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system with a hashed value includes in FQDN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("domainNameLabelScope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DnsSettings2DomainNameLabelScope? DomainNameLabelScope { get; set; }

        /// <summary>
        /// The Fully Qualified Domain Name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }

        /// <summary>
        /// The reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reverseFqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReverseFqdn { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Contains the DDoS protection settings of the public IP.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DdosSettings
    {
        /// <summary>
        /// The DDoS protection mode of the public IP
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protectionMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DdosSettingsProtectionMode? ProtectionMode { get; set; }

        /// <summary>
        /// The DDoS protection plan associated with the public IP. Can only be set if ProtectionMode is Enabled
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ddosProtectionPlan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource DdosProtectionPlan { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Contains the IpTag associated with the object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IpTags
    {
        /// <summary>
        /// The IP tag type. Example: FirstPartyUsage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipTagType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IpTagType { get; set; }

        /// <summary>
        /// The value of the IP tag associated with the public IP. Example: SQL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties16MigrationPhase
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Prepare")]
        Prepare = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Commit")]
        Commit = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Abort")]
        Abort = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Committed")]
        Committed = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties16DeleteOption
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Delete")]
        Delete = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Detach")]
        Detach = 1,

    }

    /// <summary>
    /// Backend address of an application gateway.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BackendAddresses
    {
        /// <summary>
        /// Fully qualified domain name (FQDN).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }

        /// <summary>
        /// IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IpAddress { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Gateway load balancer tunnel interface of a load balancer backend address pool.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TunnelInterfaces
    {
        /// <summary>
        /// Port of gateway load balancer tunnel interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Port { get; set; }

        /// <summary>
        /// Identifier of gateway load balancer tunnel interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Identifier { get; set; }

        /// <summary>
        /// Protocol of gateway load balancer tunnel interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TunnelInterfacesProtocol? Protocol { get; set; }

        /// <summary>
        /// Traffic type of gateway load balancer tunnel interface.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TunnelInterfacesType? Type { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Load balancer backend addresses.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoadBalancerBackendAddresses
    {
        /// <summary>
        /// Properties of load balancer backend address pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties32 Properties { get; set; }

        /// <summary>
        /// Name of the backend address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties19SyncMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Automatic")]
        Automatic = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Manual")]
        Manual = 1,

    }

    /// <summary>
    /// The transport protocol for the endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Protocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Udp")]
        Udp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"All")]
        All = 2,

    }

    /// <summary>
    /// The private link service ip configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ipConfigurations : SubResource
    {
        /// <summary>
        /// Properties of the private link service ip configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties33 Properties { get; set; }

        /// <summary>
        /// The name of private link service ip configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// The resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// PrivateEndpointConnection resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PrivateEndpointConnections : SubResource
    {
        /// <summary>
        /// Properties of the private end point connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties34 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within a resource group. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The resource type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

    }

    /// <summary>
    /// The base resource set for visibility and auto-approval.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Visibility
    {
        /// <summary>
        /// The list of subscriptions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subscriptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Subscriptions { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Sku3Name
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Basic")]
        Basic = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Gateway")]
        Gateway = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Sku3Tier
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Regional")]
        Regional = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Global")]
        Global = 1,

    }

    /// <summary>
    /// A load balancing rule for a load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LoadBalancingRules : SubResource
    {
        /// <summary>
        /// Properties of load balancer load balancing rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties35 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of load balancing rules used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// A load balancer probe.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Probes : SubResource
    {
        /// <summary>
        /// Properties of load balancer probe.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties36 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of probes used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Inbound NAT pool of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InboundNatPools : SubResource
    {
        /// <summary>
        /// Properties of load balancer inbound nat pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties37 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of inbound NAT pools used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Outbound rule of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OutboundRules : SubResource
    {
        /// <summary>
        /// Properties of load balancer outbound rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Properties38 Properties { get; set; }

        /// <summary>
        /// The name of the resource that is unique within the set of outbound rules used by the load balancer. This name can be used to access the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// A unique read-only string that changes whenever the resource is updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Etag { get; set; }

        /// <summary>
        /// Type of the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties23Protocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Udp")]
        Udp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Icmp")]
        Icmp = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Esp")]
        Esp = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"*")]
        _ = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Ah")]
        Ah = 5,

    }

    /// <summary>
    /// Hop link properties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties24
    {
        /// <summary>
        /// Minimum roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeMin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeMin { get; set; }

        /// <summary>
        /// Average roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeAvg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeAvg { get; set; }

        /// <summary>
        /// Maximum roundtrip time in milliseconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundTripTimeMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 4294967295D)]
        public long? RoundTripTimeMax { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IssuesOrigin
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Local")]
        Local = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Inbound")]
        Inbound = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Outbound")]
        Outbound = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IssuesSeverity
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Warning")]
        Warning = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IssuesType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Unknown")]
        Unknown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AgentStopped")]
        AgentStopped = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"GuestFirewall")]
        GuestFirewall = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"DnsResolution")]
        DnsResolution = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"SocketBind")]
        SocketBind = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"NetworkSecurityRule")]
        NetworkSecurityRule = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"UserDefinedRoute")]
        UserDefinedRoute = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PortThrottled")]
        PortThrottled = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"Platform")]
        Platform = 8,

    }

    /// <summary>
    /// A key-value pair that provides additional context on the issue.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Context : System.Collections.Generic.Dictionary<string, string>
    {

    }

    /// <summary>
    /// Properties of ResourceNavigationLink.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties25
    {
        /// <summary>
        /// Resource type of the linked resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkedResourceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkedResourceType { get; set; }

        /// <summary>
        /// Link to the external resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("link", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link { get; set; }

        /// <summary>
        /// The provisioning state of the resource navigation link resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of ServiceAssociationLink.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties26
    {
        /// <summary>
        /// Resource type of the linked resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkedResourceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkedResourceType { get; set; }

        /// <summary>
        /// Link to the external resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("link", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Link { get; set; }

        /// <summary>
        /// The provisioning state of the service association link resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// If true, the resource can be deleted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowDelete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowDelete { get; set; }

        /// <summary>
        /// A list of locations.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("locations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Locations { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of a service delegation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties27
    {
        /// <summary>
        /// The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceName { get; set; }

        /// <summary>
        /// The actions permitted to the service upon delegation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Actions { get; set; }

        /// <summary>
        /// The provisioning state of the service delegation resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Pool
    {
        /// <summary>
        /// Resource id of the associated Azure IpamPool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Route resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties28
    {
        /// <summary>
        /// The destination CIDR to which the route applies.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addressPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AddressPrefix { get; set; }

        /// <summary>
        /// The type of Azure hop the packet should be sent to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RouteNextHopType NextHopType { get; set; }

        /// <summary>
        /// The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nextHopIpAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NextHopIpAddress { get; set; }

        /// <summary>
        /// The provisioning state of the route resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// A value indicating whether this route overrides overlapping BGP routes regardless of LPM.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasBgpOverride", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasBgpOverride { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Service Endpoint policy definition resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties29
    {
        /// <summary>
        /// A description for this rule. Restricted to 140 chars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Service endpoint name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service { get; set; }

        /// <summary>
        /// A list of service resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceResources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> ServiceResources { get; set; }

        /// <summary>
        /// The provisioning state of the service endpoint policy definition resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the PrivateLinkServiceConnection.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties30
    {
        /// <summary>
        /// The provisioning state of the private link service connection resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The resource id of private link service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkServiceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateLinkServiceId { get; set; }

        /// <summary>
        /// The ID(s) of the group(s) obtained from the remote resource that this private endpoint should connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> GroupIds { get; set; }

        /// <summary>
        /// A message passed to the owner of the remote resource with this connection request. Restricted to 140 chars.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RequestMessage { get; set; }

        /// <summary>
        /// A collection of read-only information about the state of the connection to the remote resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkServiceConnectionState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateLinkServiceConnectionState PrivateLinkServiceConnectionState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of an IP Configuration of the private endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties31
    {
        /// <summary>
        /// The ID of a group obtained from the remote resource that this private endpoint should connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupId { get; set; }

        /// <summary>
        /// The member name of a group obtained from the remote resource that this private endpoint should connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("memberName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MemberName { get; set; }

        /// <summary>
        /// A private ip address obtained from the private endpoint's subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateIPAddress { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FormatType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"JSON")]
        JSON = 0,

    }

    /// <summary>
    /// Parameters that define the configuration of traffic analytics.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NetworkWatcherFlowAnalyticsConfiguration
    {
        /// <summary>
        /// Flag to enable/disable traffic analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// The resource guid of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceId { get; set; }

        /// <summary>
        /// The location of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceRegion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceRegion { get; set; }

        /// <summary>
        /// Resource Id of the attached workspace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workspaceResourceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkspaceResourceId { get; set; }

        /// <summary>
        /// The interval in minutes which would decide how frequently TA service should do flow analytics.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trafficAnalyticsInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TrafficAnalyticsInterval { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DnsSettings2DomainNameLabelScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"TenantReuse")]
        TenantReuse = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SubscriptionReuse")]
        SubscriptionReuse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ResourceGroupReuse")]
        ResourceGroupReuse = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"NoReuse")]
        NoReuse = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DdosSettingsProtectionMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"VirtualNetworkInherited")]
        VirtualNetworkInherited = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TunnelInterfacesProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Native")]
        Native = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"VXLAN")]
        VXLAN = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TunnelInterfacesType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Internal")]
        Internal = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"External")]
        External = 2,

    }

    /// <summary>
    /// Properties of the load balancer backend addresses.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties32
    {
        /// <summary>
        /// Reference to an existing virtual network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("virtualNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource VirtualNetwork { get; set; }

        /// <summary>
        /// Reference to an existing subnet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource Subnet { get; set; }

        /// <summary>
        /// IP Address belonging to the referenced virtual network.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IpAddress { get; set; }

        /// <summary>
        /// Reference to IP address defined in network interfaces.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("networkInterfaceIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource NetworkInterfaceIPConfiguration { get; set; }

        /// <summary>
        /// Reference to the frontend ip address configuration defined in regional loadbalancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancerFrontendIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource LoadBalancerFrontendIPConfiguration { get; set; }

        /// <summary>
        /// Collection of inbound NAT rule port mappings.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatRulesPortMapping", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<InboundNatRulesPortMapping> InboundNatRulesPortMapping { get; set; }

        /// <summary>
        /// A list of administrative states which once set can override health probe so that Load Balancer will always forward new connections to backend, or deny new connections and reset existing connections.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("adminState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties32AdminState? AdminState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of private link service IP configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties33
    {
        /// <summary>
        /// The private IP address of the IP configuration.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateIPAddress { get; set; }

        /// <summary>
        /// The private IP address allocation method.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAllocationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPAllocationMethod? PrivateIPAllocationMethod { get; set; }

        /// <summary>
        /// The reference to the subnet resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Subnet Subnet { get; set; }

        /// <summary>
        /// Whether the ip configuration is primary or not.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Primary { get; set; }

        /// <summary>
        /// The provisioning state of the private link service IP configuration resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateIPAddressVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IPVersion? PrivateIPAddressVersion { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the PrivateEndpointConnectProperties.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties34
    {
        /// <summary>
        /// The resource of private end point.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateEndpoint PrivateEndpoint { get; set; }

        /// <summary>
        /// A collection of information about the state of the connection between service consumer and provider.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateLinkServiceConnectionState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PrivateLinkServiceConnectionState PrivateLinkServiceConnectionState { get; set; }

        /// <summary>
        /// The provisioning state of the private endpoint connection resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The consumer link id.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("linkIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LinkIdentifier { get; set; }

        /// <summary>
        /// The location of the private endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privateEndpointLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PrivateEndpointLocation { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties35
    {
        /// <summary>
        /// A reference to frontend IP addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource FrontendIPConfiguration { get; set; }

        /// <summary>
        /// A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend IPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddressPool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource BackendAddressPool { get; set; }

        /// <summary>
        /// An array of references to pool of DIPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddressPools", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> BackendAddressPools { get; set; }

        /// <summary>
        /// The reference to the load balancer probe used by the load balancing rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource Probe { get; set; }

        /// <summary>
        /// The reference to the transport protocol used by the load balancing rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Protocol Protocol { get; set; }

        /// <summary>
        /// The load distribution policy for this rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadDistribution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties35LoadDistribution? LoadDistribution { get; set; }

        /// <summary>
        /// The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 0 and 65534. Note that value 0 enables "Any Port".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPort", Required = Newtonsoft.Json.Required.Always)]
        public int FrontendPort { get; set; }

        /// <summary>
        /// The port used for internal connections on the endpoint. Acceptable values are between 0 and 65535. Note that value 0 enables "Any Port".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BackendPort { get; set; }

        /// <summary>
        /// The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        /// <summary>
        /// Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableFloatingIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableFloatingIP { get; set; }

        /// <summary>
        /// Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableTcpReset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableTcpReset { get; set; }

        /// <summary>
        /// Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the frontend of the load balancing rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableOutboundSnat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableOutboundSnat { get; set; }

        /// <summary>
        /// The provisioning state of the load balancing rule resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Load balancer probe resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties36
    {
        /// <summary>
        /// The load balancer rules that use this probe.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("loadBalancingRules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SubResource> LoadBalancingRules { get; set; }

        /// <summary>
        /// The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties36Protocol Protocol { get; set; }

        /// <summary>
        /// The port for communicating the probe. Possible values range from 1 to 65535, inclusive.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }

        /// <summary>
        /// The interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking the instance out of rotation. The default value is 15, the minimum value is 5.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("intervalInSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IntervalInSeconds { get; set; }

        /// <summary>
        /// Determines how new connections are handled by the load balancer when all backend instances are probed down.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("noHealthyBackendsBehavior", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties36NoHealthyBackendsBehavior? NoHealthyBackendsBehavior { get; set; }

        /// <summary>
        /// The number of probes where if no response, will result in stopping further traffic from being delivered to the endpoint. This values allows endpoints to be taken out of rotation faster or slower than the typical times used in Azure.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("numberOfProbes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfProbes { get; set; }

        /// <summary>
        /// The number of consecutive successful or failed probes in order to allow or deny traffic from being delivered to this endpoint. After failing the number of consecutive probes equal to this value, the endpoint will be taken out of rotation and require the same number of successful consecutive probes to be placed back in rotation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("probeThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ProbeThreshold { get; set; }

        /// <summary>
        /// The URI used for requesting health status from the VM. Path is required if a protocol is set to http. Otherwise, it is not allowed. There is no default value.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RequestPath { get; set; }

        /// <summary>
        /// The provisioning state of the probe resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of Inbound NAT pool.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties37
    {
        /// <summary>
        /// A reference to frontend IP addresses.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendIPConfiguration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubResource FrontendIPConfiguration { get; set; }

        /// <summary>
        /// The reference to the transport protocol used by the inbound NAT pool.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Protocol Protocol { get; set; }

        /// <summary>
        /// The first port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65534.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPortRangeStart", Required = Newtonsoft.Json.Required.Always)]
        public int FrontendPortRangeStart { get; set; }

        /// <summary>
        /// The last port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPortRangeEnd", Required = Newtonsoft.Json.Required.Always)]
        public int FrontendPortRangeEnd { get; set; }

        /// <summary>
        /// The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendPort", Required = Newtonsoft.Json.Required.Always)]
        public int BackendPort { get; set; }

        /// <summary>
        /// The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        /// <summary>
        /// Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableFloatingIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableFloatingIP { get; set; }

        /// <summary>
        /// Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableTcpReset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableTcpReset { get; set; }

        /// <summary>
        /// The provisioning state of the inbound NAT pool resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Outbound rule of the load balancer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties38
    {
        /// <summary>
        /// The number of outbound ports to be used for NAT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allocatedOutboundPorts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AllocatedOutboundPorts { get; set; }

        /// <summary>
        /// The Frontend IP addresses of the load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendIPConfigurations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.List<SubResource> FrontendIPConfigurations { get; set; } = new System.Collections.Generic.List<SubResource>();

        /// <summary>
        /// A reference to a pool of DIPs. Outbound traffic is randomly load balanced across IPs in the backend IPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendAddressPool", Required = Newtonsoft.Json.Required.Always)]
        public SubResource BackendAddressPool { get; set; }

        /// <summary>
        /// The provisioning state of the outbound rule resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("provisioningState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProvisioningState? ProvisioningState { get; set; }

        /// <summary>
        /// The protocol for the outbound rule in load balancer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Properties38Protocol Protocol { get; set; }

        /// <summary>
        /// Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableTcpReset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableTcpReset { get; set; }

        /// <summary>
        /// The timeout for the TCP idle connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("idleTimeoutInMinutes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IdleTimeoutInMinutes { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Individual port mappings for inbound NAT rule created for backend pool.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InboundNatRulesPortMapping
    {
        /// <summary>
        /// Name of inbound NAT rule.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inboundNatRuleName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InboundNatRuleName { get; set; }

        /// <summary>
        /// Frontend port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("frontendPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FrontendPort { get; set; }

        /// <summary>
        /// Backend port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backendPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BackendPort { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties32AdminState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Up")]
        Up = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Down")]
        Down = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties35LoadDistribution
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SourceIP")]
        SourceIP = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SourceIPProtocol")]
        SourceIPProtocol = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties36Protocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Http")]
        Http = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Https")]
        Https = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties36NoHealthyBackendsBehavior
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AllProbedDown")]
        AllProbedDown = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AllProbedUp")]
        AllProbedUp = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties38Protocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Tcp")]
        Tcp = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Udp")]
        Udp = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"All")]
        All = 2,

    }


}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625